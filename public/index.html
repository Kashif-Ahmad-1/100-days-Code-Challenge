
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 Days of Code Interview Questions</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-bold text-center mb-8">100 Days of Code: JavaScript & Node.js Interview Questions</h1>
        <div class="flex flex-wrap gap-4 mb-8">
            <button onclick="loadDay('Day-01')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-01</button><button onclick="loadDay('Day-02')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-02</button><button onclick="loadDay('Day-03')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-03</button><button onclick="loadDay('Day-04')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-04</button><button onclick="loadDay('Day-05')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-05</button><button onclick="loadDay('Day-06')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-06</button><button onclick="loadDay('Day-07')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-07</button><button onclick="loadDay('Day-08')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-08</button><button onclick="loadDay('Day-09')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-09</button><button onclick="loadDay('Day-10')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-10</button><button onclick="loadDay('Day-11')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-11</button><button onclick="loadDay('Day-12')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-12</button><button onclick="loadDay('Day-13')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-13</button><button onclick="loadDay('Day-14')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-14</button><button onclick="loadDay('Day-15')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-15</button><button onclick="loadDay('Day-16')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-16</button><button onclick="loadDay('Day-17')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Day-17</button>
        </div>
        <div id="questions" class="space-y-6"></div>
    </div>
    <script>
        const questionsData = [{"day":"Day-01","questions":[]},{"day":"Day-02","questions":[]},{"day":"Day-03","questions":[]},{"day":"Day-04","questions":[]},{"day":"Day-05","questions":[]},{"day":"Day-06","questions":[]},{"day":"Day-07","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Hoisting**: Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase. For `var`, both declaration and initialization (to `undefined`) are hoisted. For `let` and `const`, only the declaration is hoisted, but they are not initialized, leading to the \"temporal dead zone\" if accessed before their actual declaration line.\n    *   **When to choose `const`**: You should choose `const` when you declare a variable whose value is not expected to change throughout its lifecycle. This improves code readability and helps prevent accidental re-assignment bugs. If the value needs to change, then `let` is appropriate. `var` is generally discouraged in modern JavaScript.\n    *   **Redeclaring `let` in inner block**: Yes, you can redeclare a `let` variable in an inner block scope. This creates a new variable local to that inner block, effectively \"shadowing\" the outer variable.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // var example\n    console.log(myVar); // undefined (hoisted)\n    var myVar = \"Hello\";\n    console.log(myVar); // Hello\n    var myVar = \"World\"; // Re-declaration allowed\n    console.log(myVar); // World\n\n    // let example\n    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization (temporal dead zone)\n    let myLet = \"Hello\";\n    console.log(myLet); // Hello\n    myLet = \"World\"; // Re-assignment allowed\n    // let myLet = \"Again\"; // SyntaxError: Identifier 'myLet' has already been declared\n\n    // const example\n    const myConst = \"Hello\";\n    // myConst = \"World\"; // TypeError: Assignment to constant variable.\n    const myObject = { name: \"Alice\" };\n    myObject.name = \"Bob\"; // Allowed: modifying object property, not reassigning the reference\n    console.log(myObject); // { name: 'Bob' }\n\n    // Block scoping with let/const\n    let outerVar = \"I'm outside\";\n    if (true) {\n      let outerVar = \"I'm inside the block\"; // This is a new 'outerVar' specific to this block\n      console.log(outerVar); // I'm inside the block\n    }\n    console.log(outerVar); // I'm outside (the outer one is unaffected)\n    ```\n\n---"],"codeExamples":["// var example\n    console.log(myVar); // undefined (hoisted)\n    var myVar = \"Hello\";\n    console.log(myVar); // Hello\n    var myVar = \"World\"; // Re-declaration allowed\n    console.log(myVar); // World\n\n    // let example\n    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization (temporal dead zone)\n    let myLet = \"Hello\";\n    console.log(myLet); // Hello\n    myLet = \"World\"; // Re-assignment allowed\n    // let myLet = \"Again\"; // SyntaxError: Identifier 'myLet' has already been declared\n\n    // const example\n    const myConst = \"Hello\";\n    // myConst = \"World\"; // TypeError: Assignment to constant variable.\n    const myObject = { name: \"Alice\" };\n    myObject.name = \"Bob\"; // Allowed: modifying object property, not reassigning the reference\n    console.log(myObject); // { name: 'Bob' }\n\n    // Block scoping with let/const\n    let outerVar = \"I'm outside\";\n    if (true) {\n      let outerVar = \"I'm inside the block\"; // This is a new 'outerVar' specific to this block\n      console.log(outerVar); // I'm inside the block\n    }\n    console.log(outerVar); // I'm outside (the outer one is unaffected)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Example of copying**:\n        ```javascript\n        // Primitive copy\n        let a = 10;\n        let b = a; // b gets a copy of 10\n        b = 20;\n        console.log(a); // 10 (a is unaffected)\n\n        // Reference copy\n        let obj1 = { value: 10 };\n        let obj2 = obj1; // obj2 gets a copy of the reference to the same object\n        obj2.value = 20;\n        console.log(obj1.value); // 20 (obj1 is affected because both point to the same object)\n        ```\n    *   **Importance**: This distinction is crucial for understanding how data is manipulated. If you don't grasp it, you might accidentally modify an object through one variable when you intended to only modify it through another, leading to hard-to-debug side effects. It's fundamental to understanding object mutation and function arguments.\n    *   **`null`**: `null` is a primitive data type. The fact that `typeof null` returns 'object' is a long-standing bug in JavaScript that dates back to the very first implementation and has been maintained for backward compatibility.\n\n5.  **Code Example(s)**: (See follow-up answers for examples)\n\n---"],"codeExamples":[]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Temporal Dead Zone (TDZ)**: The TDZ is a period of time during which `let` and `const` variables exist but cannot be accessed. It starts from the beginning of the block scope until the variable's declaration is executed. During this time, accessing the variable will result in a `ReferenceError`, unlike `var` which would return `undefined`. This mechanism helps catch potential bugs where variables are used before they are properly initialized.\n    *   **Function Expressions vs. Declarations**: Function declarations are parsed and added to the execution context before any code runs, making them available everywhere in their scope. Function expressions, however, are assigned to a variable, and thus follow the hoisting rules of variables (`var`, `let`, or `const`). If it's a `var` function expression, the variable is hoisted as `undefined`; if `let`/`const`, it's in the TDZ. The function definition itself is not available until that line of code is executed.\n    *   **Impact on Order**: Hoisting allows you to call function declarations before their actual definition in the code. For `var` variables, you can access them before their declaration, but their value will be `undefined` until the assignment line is reached. For `let` and `const`, you *must* declare them before you access them, or you'll get a `ReferenceError`. This encourages a more structured coding style where variables are declared close to their first use.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Variable Hoisting (with var)\n    console.log(car); // undefined (declaration hoisted, assignment not)\n    var car = \"Honda\";\n    console.log(car); // Honda\n\n    // Function Hoisting\n    sayHello(); // \"Hello from a hoisted function!\"\n    function sayHello() {\n      console.log(\"Hello from a hoisted function!\");\n    }\n\n    // Function Expression (not fully hoisted)\n    // sayGoodbye(); // TypeError: sayGoodbye is not a function (if using var)\n    // sayGoodbye(); // ReferenceError: Cannot access 'sayGoodbye' before initialization (if using let/const)\n    const sayGoodbye = function() {\n      console.log(\"Goodbye!\");\n    };\n    sayGoodbye(); // Goodbye! (after declaration)\n    ```\n\n---"],"codeExamples":["// Variable Hoisting (with var)\n    console.log(car); // undefined (declaration hoisted, assignment not)\n    var car = \"Honda\";\n    console.log(car); // Honda\n\n    // Function Hoisting\n    sayHello(); // \"Hello from a hoisted function!\"\n    function sayHello() {\n      console.log(\"Hello from a hoisted function!\");\n    }\n\n    // Function Expression (not fully hoisted)\n    // sayGoodbye(); // TypeError: sayGoodbye is not a function (if using var)\n    // sayGoodbye(); // ReferenceError: Cannot access 'sayGoodbye' before initialization (if using let/const)\n    const sayGoodbye = function() {\n      console.log(\"Goodbye!\");\n    };\n    sayGoodbye(); // Goodbye! (after declaration)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Example**:\n        ```javascript\n        console.log(5 == '5');   // true (string '5' is coerced to number 5)\n        console.log(5 === '5');  // false (different types: number vs string)\n\n        console.log(null == undefined); // true\n        console.log(null === undefined); // false\n        ```\n    *   **Recommendation for `===`**: It's generally recommended to use `===` because it prevents unexpected type coercion behavior, making your code more predictable and less prone to bugs. It enforces stricter type checking, which leads to more robust and easier-to-debug code.\n    *   **Scenarios for `==`**: While `===` is preferred, `==` can be acceptable or even slightly more concise in specific, well-understood scenarios. A common example is checking for `null` or `undefined` values simultaneously: `myVar == null` will return `true` if `myVar` is either `null` or `undefined`. This is shorthand for `myVar === null || myVar === undefined`. However, even in this case, being explicit with `===` is often clearer.\n\n5.  **Code Example(s)**: (See follow-up answers for examples)\n\n---"],"codeExamples":[]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Lexical Scope**: Lexical scope (or static scope) means that the scope of a variable is defined by its position in the source code at the time of writing, not at runtime. In nested functions, an inner function has access to variables defined in its own scope, its outer (enclosing) function's scope, and the global scope. This is fundamental to closures.\n    *   **Undeclared Variables**: If you declare a variable inside a function without `var`, `let`, or `const` (e.g., `x = 10;`), it automatically becomes a global variable. This is a common source of bugs and is highly discouraged, especially in strict mode, where it will throw a `ReferenceError`.\n    *   **Avoiding Global Scope Pollution**: Polluting the global scope can lead to naming conflicts with other scripts or libraries, making debugging difficult and potentially overwriting important variables. It also makes your code less modular and harder to maintain. Using `let` and `const` for block-scoping and encapsulating code within functions helps minimize global variable usage.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global Scope\n    const globalVar = \"I'm global\";\n\n    function outerFunction() {\n      // Function Scope (for var)\n      var functionVar = \"I'm function-scoped\";\n      console.log(globalVar); // Accessible\n\n      if (true) {\n        // Block Scope (for let/const)\n        let blockLet = \"I'm block-scoped (let)\";\n        const blockConst = \"I'm block-scoped (const)\";\n        console.log(functionVar); // Accessible (within outerFunction's scope)\n        console.log(blockLet); // Accessible\n        console.log(blockConst); // Accessible\n      }\n\n      // console.log(blockLet); // ReferenceError: blockLet is not defined (outside its block)\n    }\n\n    outerFunction();\n    // console.log(functionVar); // ReferenceError: functionVar is not defined (outside its function)\n    console.log(globalVar); // Accessible\n    ```\n\n---"],"codeExamples":["// Global Scope\n    const globalVar = \"I'm global\";\n\n    function outerFunction() {\n      // Function Scope (for var)\n      var functionVar = \"I'm function-scoped\";\n      console.log(globalVar); // Accessible\n\n      if (true) {\n        // Block Scope (for let/const)\n        let blockLet = \"I'm block-scoped (let)\";\n        const blockConst = \"I'm block-scoped (const)\";\n        console.log(functionVar); // Accessible (within outerFunction's scope)\n        console.log(blockLet); // Accessible\n        console.log(blockConst); // Accessible\n      }\n\n      // console.log(blockLet); // ReferenceError: blockLet is not defined (outside its block)\n    }\n\n    outerFunction();\n    // console.log(functionVar); // ReferenceError: functionVar is not defined (outside its function)\n    console.log(globalVar); // Accessible"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **`this` behavior example**:\n        ```javascript\n        const person = {\n          name: 'Alice',\n          regularGreet: function() {\n            // 'this' refers to 'person' object\n            setTimeout(function() {\n              console.log(`Regular: Hello, my name is ${this.name}`); // 'this' is window/undefined in strict mode\n            }, 100);\n          },\n          arrowGreet: function() {\n            // 'this' refers to 'person' object\n            setTimeout(() => {\n              console.log(`Arrow: Hello, my name is ${this.name}`); // 'this' is lexically bound to 'person'\n            }, 100);\n          }\n        };\n\n        person.regularGreet(); // Output: Regular: Hello, my name is (or error in strict mode)\n        person.arrowGreet();   // Output: Arrow: Hello, my name is Alice\n        ```\n    *   **When to choose**: Arrow functions are excellent for callbacks, especially in array methods (like `map`, `filter`, `reduce`) or asynchronous operations (like `setTimeout`, Promises), where preserving the `this` context of the surrounding code is desirable. Regular functions are more appropriate for object methods (where `this` should refer to the object itself), constructors, or when you need the `arguments` object.\n    *   **Single-line arrow function**:\n        ```javascript\n        const add = (a, b) => a + b;\n        console.log(add(2, 3)); // 5\n\n        const getObject = (id, name) => ({ id, name }); // Parentheses needed for object literal\n        console.log(getObject(1, 'Test')); // { id: 1, name: 'Test' }\n        ```\n\n5.  **Code Example(s)**: (See follow-up answers for examples)\n\n---"],"codeExamples":[]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **`call()`, `apply()`, `bind()`**: These methods allow you to explicitly define the `this` context for a function.\n        *   `call(thisArg, arg1, arg2, ...)`: Invokes the function immediately, setting `this` to `thisArg` and taking arguments individually.\n        *   `apply(thisArg, [argsArray])`: Invokes the function immediately, setting `this` to `thisArg` and taking arguments as an array.\n        *   `bind(thisArg, arg1, arg2, ...)`: Returns a *new function* with `this` permanently bound to `thisArg` (and optionally pre-set arguments). It does not invoke the function immediately.\n        The main difference between `call()` and `apply()` is how they accept arguments: `call()` takes them as a comma-separated list, while `apply()` takes them as an array.\n    *   **Source of Confusion**: The dynamic nature of `this` is confusing because its value changes based on the *invocation* context, not just where the function is defined. Developers often expect `this` to behave like `self` or `this` in other object-oriented languages, where it consistently refers to the instance of the class.\n    *   **`showThis()` in browser**: In a non-strict browser environment, when `showThis()` is called directly, `this` would refer to the global `window` object.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global context\n    console.log(this === window); // true (in browser)\n\n    const user = {\n      name: 'John',\n      greet: function() {\n        console.log(`Hello, ${this.name}`); // 'this' refers to 'user'\n      }\n    };\n    user.greet(); // Hello, John (Method call)\n\n    const standaloneGreet = user.greet;\n    // standaloneGreet(); // Hello, undefined (or TypeError in strict mode) - 'this' is window/undefined\n\n    // Constructor call\n    function Person(name) {\n      this.name = name;\n    }\n    const person1 = new Person('Alice');\n    console.log(person1.name); // Alice ('this' refers to the new instance)\n\n    // Explicit binding with call()\n    function introduce(age) {\n      console.log(`My name is ${this.name} and I am ${age} years old.`);\n    }\n    const anotherUser = { name: 'Bob' };\n    introduce.call(anotherUser, 30); // My name is Bob and I am 30 years old.\n    ```\n\n---"],"codeExamples":["// Global context\n    console.log(this === window); // true (in browser)\n\n    const user = {\n      name: 'John',\n      greet: function() {\n        console.log(`Hello, ${this.name}`); // 'this' refers to 'user'\n      }\n    };\n    user.greet(); // Hello, John (Method call)\n\n    const standaloneGreet = user.greet;\n    // standaloneGreet(); // Hello, undefined (or TypeError in strict mode) - 'this' is window/undefined\n\n    // Constructor call\n    function Person(name) {\n      this.name = name;\n    }\n    const person1 = new Person('Alice');\n    console.log(person1.name); // Alice ('this' refers to the new instance)\n\n    // Explicit binding with call()\n    function introduce(age) {\n      console.log(`My name is ${this.name} and I am ${age} years old.`);\n    }\n    const anotherUser = { name: 'Bob' };\n    introduce.call(anotherUser, 30); // My name is Bob and I am 30 years old."]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Long synchronous operation**: If a synchronous operation takes a very long time (e.g., a complex calculation or an infinite loop), it will block the entire single thread. The Event Loop will not be able to pull any callbacks from the queue, meaning the application will become unresponsive, unable to process I/O events, timers, or network requests until that synchronous operation completes. This is known as \"blocking the event loop\" and is highly undesirable.\n    *   **Common asynchronous scenarios**:\n        1.  **File System Operations**: Reading from or writing to files (e.g., `fs.readFile()`, `fs.writeFile()`).\n        2.  **Network Requests**: Making HTTP requests (e.g., using `http.get()`, `axios`), or handling incoming requests in a web server.\n        3.  **Timers**: `setTimeout()`, `setInterval()`.\n        4.  **Database Queries**: Interacting with databases.\n    *   **Microtask Queue**: The Event Loop has a priority queue called the \"microtask queue\" (or \"job queue\") which holds callbacks from Promises (`.then()`, `.catch()`, `.finally()`) and `process.nextTick()`. Microtasks are processed *before* the Event Loop moves to the next macrotask (callbacks from `setTimeout`, I/O, etc.) in the main callback queue. This means that all pending microtasks are executed immediately after the current script finishes and before the next cycle of the Event Loop starts.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example of non-blocking I/O with Event Loop\n    console.log('Start');\n\n    // Asynchronous operation (offloaded)\n    setTimeout(() => {\n      console.log('Timer callback executed');\n    }, 0); // Even with 0ms, it goes to the queue\n\n    // Another asynchronous operation\n    const fs = require('fs');\n    fs.readFile('./example.txt', 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File read callback executed:', data);\n    });\n\n    console.log('End'); // This runs before the callbacks, demonstrating non-blocking\n\n    // Expected (approximate) output:\n    // Start\n    // End\n    // Timer callback executed\n    // File read callback executed: (content of example.txt)\n    // (Note: File read might finish before or after timer depending on system)\n    ```\n    *(To run this, create an `example.txt` file in the same directory with some content like \"Hello Node!\")*\n\n---"],"codeExamples":["// Example of non-blocking I/O with Event Loop\n    console.log('Start');\n\n    // Asynchronous operation (offloaded)\n    setTimeout(() => {\n      console.log('Timer callback executed');\n    }, 0); // Even with 0ms, it goes to the queue\n\n    // Another asynchronous operation\n    const fs = require('fs');\n    fs.readFile('./example.txt', 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File read callback executed:', data);\n    });\n\n    console.log('End'); // This runs before the callbacks, demonstrating non-blocking\n\n    // Expected (approximate) output:\n    // Start\n    // End\n    // Timer callback executed\n    // File read callback executed: (content of example.txt)\n    // (Note: File read might finish before or after timer depending on system)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":[],"codeExamples":[]}]},{"day":"Day-08","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Logical Operators**:\n        *   The `&&` (AND) operator returns the *first falsy value* it encounters. If all values are truthy, it returns the *last truthy value*.\n        *   The `||` (OR) operator returns the *first truthy value* it encounters. If all values are falsy, it returns the *last falsy value*.\n    *   **Short-circuiting**: This refers to the behavior where the logical operators `&&` and `||` evaluate expressions from left to right and stop as soon as they can determine the final result. For `&&`, if the first operand is falsy, it immediately returns that value without evaluating the second operand. For `||`, if the first operand is truthy, it immediately returns that value without evaluating the second operand. This can be useful for providing default values or conditional execution.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Falsy examples\n    if (0) {\n        console.log(\"This will not be logged.\");\n    }\n\n    if (\"\") {\n        console.log(\"This will not be logged.\");\n    }\n\n    // Truthy example\n    if (\"hello\") {\n        console.log(\"'hello' is truthy.\"); // This will be logged\n    }\n\n    // Short-circuiting with &&\n    const name = \"\";\n    const defaultName = name && \"Guest\"; // defaultName will be \"\" (falsy)\n    console.log(defaultName);\n\n    // Short-circuiting with ||\n    const user = null;\n    const displayName = user || \"Anonymous\"; // displayName will be \"Anonymous\" (first truthy)\n    console.log(displayName);\n\n    const result = 5 && 10; // result will be 10 (last truthy)\n    console.log(result);\n    ```\n\n---"],"codeExamples":["// Falsy examples\n    if (0) {\n        console.log(\"This will not be logged.\");\n    }\n\n    if (\"\") {\n        console.log(\"This will not be logged.\");\n    }\n\n    // Truthy example\n    if (\"hello\") {\n        console.log(\"'hello' is truthy.\"); // This will be logged\n    }\n\n    // Short-circuiting with &&\n    const name = \"\";\n    const defaultName = name && \"Guest\"; // defaultName will be \"\" (falsy)\n    console.log(defaultName);\n\n    // Short-circuiting with ||\n    const user = null;\n    const displayName = user || \"Anonymous\"; // displayName will be \"Anonymous\" (first truthy)\n    console.log(displayName);\n\n    const result = 5 && 10; // result will be 10 (last truthy)\n    console.log(result);"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Explicit Type Conversion**: Developers can manually convert types using built-in functions or constructors.\n        *   To Number: `Number(\"123\")`, `parseInt(\"42px\")`, `parseFloat(\"3.14\")`\n        *   To String: `String(123)`, `(123).toString()`\n        *   To Boolean: `Boolean(0)`, `!!value` (double NOT operator)\n    *   **`parseInt()` vs `Number()`**:\n        *   `parseInt()` parses a string argument and returns an integer. It reads the string character by character from left to right and stops parsing when it encounters a non-numeric character (other than a sign or a decimal point if used with `parseFloat`). It also takes an optional `radix` argument for number base.\n        *   `Number()` is a constructor (or function when used without `new`) that attempts to convert its argument to a number. It is stricter than `parseInt()`; if the string contains *any* non-numeric characters (other than a single decimal point), it will result in `NaN`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Implicit Type Coercion Example\n    console.log(\"5\" + 5); // Output: \"55\" (string concatenation, not addition)\n    console.log(\"5\" - 5); // Output: 0 (subtraction forces \"5\" to a number)\n    console.log([] + {});  // Output: \"[object Object]\" (array converted to string, then concatenated)\n    console.log({} + []);  // Output: 0 (In browser console, this might be \"[object Object]\", but in Node.js or if wrapped in parentheses like `({} + [])` it's 0. This is due to how JS engine parses leading curly braces.)\n\n    // Explicit Type Conversion Examples\n    let strNum = \"123\";\n    let num = Number(strNum); // num is 123 (number)\n    console.log(num, typeof num);\n\n    let strPx = \"42px\";\n    let parsedInt = parseInt(strPx); // parsedInt is 42\n    let numFromPx = Number(strPx); // numFromPx is NaN\n    console.log(parsedInt, numFromPx);\n    ```\n\n---"],"codeExamples":["// Implicit Type Coercion Example\n    console.log(\"5\" + 5); // Output: \"55\" (string concatenation, not addition)\n    console.log(\"5\" - 5); // Output: 0 (subtraction forces \"5\" to a number)\n    console.log([] + {});  // Output: \"[object Object]\" (array converted to string, then concatenated)\n    console.log({} + []);  // Output: 0 (In browser console, this might be \"[object Object]\", but in Node.js or if wrapped in parentheses like `({} + [])` it's 0. This is due to how JS engine parses leading curly braces.)\n\n    // Explicit Type Conversion Examples\n    let strNum = \"123\";\n    let num = Number(strNum); // num is 123 (number)\n    console.log(num, typeof num);\n\n    let strPx = \"42px\";\n    let parsedInt = parseInt(strPx); // parsedInt is 42\n    let numFromPx = Number(strPx); // numFromPx is NaN\n    console.log(parsedInt, numFromPx);"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Iterable Object**: An object is \"iterable\" if it implements the iterable protocol, meaning it has a method accessible via `Symbol.iterator` that returns an iterator. This iterator is an object with a `next()` method that returns objects with `value` and `done` properties. Common built-in iterables include `Array`, `String`, `Map`, `Set`, `TypedArray`, `arguments` object, and `NodeList`.\n    *   **Plain JavaScript Objects**: No, you cannot use `for...of` directly on a plain JavaScript object (e.g., `{ key: value }`) because plain objects are not inherently iterable. They do not have the `Symbol.iterator` method. To iterate over object properties, you would typically use `for...in` (for keys), `Object.keys()` (for keys), `Object.values()` (for values), or `Object.entries()` (for key-value pairs) combined with `forEach` or a `for...of` loop over the resulting array.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Iterating over an Array\n    const numbers = [10, 20, 30];\n    for (const num of numbers) {\n        console.log(num); // Outputs: 10, 20, 30\n    }\n\n    // Iterating over a String\n    const greeting = \"Hello\";\n    for (const char of greeting) {\n        console.log(char); // Outputs: H, e, l, l, o\n    }\n\n    // Example of why not to use for...of on plain objects directly\n    const person = { name: \"Alice\", age: 30 };\n    // This would throw an error: TypeError: person is not iterable\n    // for (const prop of person) {\n    //     console.log(prop);\n    // }\n\n    // Correct way to iterate object properties\n    for (const key in person) {\n        console.log(key, person[key]); // Outputs: name Alice, age 30\n    }\n    for (const [key, value] of Object.entries(person)) {\n        console.log(key, value); // Outputs: name Alice, age 30\n    }\n    ```\n\n---"],"codeExamples":["// Iterating over an Array\n    const numbers = [10, 20, 30];\n    for (const num of numbers) {\n        console.log(num); // Outputs: 10, 20, 30\n    }\n\n    // Iterating over a String\n    const greeting = \"Hello\";\n    for (const char of greeting) {\n        console.log(char); // Outputs: H, e, l, l, o\n    }\n\n    // Example of why not to use for...of on plain objects directly\n    const person = { name: \"Alice\", age: 30 };\n    // This would throw an error: TypeError: person is not iterable\n    // for (const prop of person) {\n    //     console.log(prop);\n    // }\n\n    // Correct way to iterate object properties\n    for (const key in person) {\n        console.log(key, person[key]); // Outputs: name Alice, age 30\n    }\n    for (const [key, value] of Object.entries(person)) {\n        console.log(key, value); // Outputs: name Alice, age 30\n    }"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Accepting Arguments**: Yes, an IIFE can accept arguments just like any other function. You pass them to the outer parentheses that invoke the function.\n        ```javascript\n        (function(message) {\n            console.log(message);\n        })(\"Hello from IIFE!\"); // Outputs: Hello from IIFE!\n        ```\n    *   **Preventing Variable Collisions**: Variables declared with `var`, `let`, or `const` inside an IIFE are scoped to that function. Because the function is immediately executed and then its execution context is typically removed (unless its inner functions form closures), these variables are not exposed to the global scope. This prevents situations where two different scripts or parts of the same script might accidentally declare variables with the same name, leading to conflicts.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Basic IIFE structure\n    (function() {\n        var privateVariable = \"I'm private!\";\n        console.log(privateVariable); // Accessible inside\n    })();\n\n    // console.log(privateVariable); // Throws ReferenceError: privateVariable is not defined\n\n    // IIFE used for module pattern (simple example)\n    const myModule = (function() {\n        let counter = 0; // private variable\n\n        function increment() {\n            counter++;\n            console.log(\"Counter:\", counter);\n        }\n\n        function reset() {\n            counter = 0;\n            console.log(\"Counter reset.\");\n        }\n\n        return { // Public interface\n            increment: increment,\n            reset: reset\n        };\n    })();\n\n    myModule.increment(); // Outputs: Counter: 1\n    myModule.increment(); // Outputs: Counter: 2\n    myModule.reset();     // Outputs: Counter reset.\n    // console.log(myModule.counter); // undefined, counter is private\n    ```\n\n---"],"codeExamples":["// Basic IIFE structure\n    (function() {\n        var privateVariable = \"I'm private!\";\n        console.log(privateVariable); // Accessible inside\n    })();\n\n    // console.log(privateVariable); // Throws ReferenceError: privateVariable is not defined\n\n    // IIFE used for module pattern (simple example)\n    const myModule = (function() {\n        let counter = 0; // private variable\n\n        function increment() {\n            counter++;\n            console.log(\"Counter:\", counter);\n        }\n\n        function reset() {\n            counter = 0;\n            console.log(\"Counter reset.\");\n        }\n\n        return { // Public interface\n            increment: increment,\n            reset: reset\n        };\n    })();\n\n    myModule.increment(); // Outputs: Counter: 1\n    myModule.increment(); // Outputs: Counter: 2\n    myModule.reset();     // Outputs: Counter reset.\n    // console.log(myModule.counter); // undefined, counter is private"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **`Array.prototype.filter()`**: You would choose `filter()` when you want to create a *new array* containing only the elements from the original array that satisfy a specific condition. The callback function for `filter()` should return a boolean (`true` to keep the element, `false` to discard it).\n    *   **Chaining `map()`**: Yes, `map()` can be chained with other array methods because it returns a new array.\n        ```javascript\n        const numbers = [1, 2, 3, 4, 5];\n        const doubledEvens = numbers\n            .filter(num => num % 2 === 0) // Filters: [2, 4]\n            .map(num => num * 2);        // Maps: [4, 8]\n\n        console.log(doubledEvens); // Output: [4, 8]\n        ```\n5.  **Code Example(s)**:\n\n    ```javascript\n    const numbers = [1, 2, 3, 4, 5];\n\n    // Using map() to double each number\n    const doubledNumbers = numbers.map(num => num * 2);\n    console.log(\"Original numbers:\", numbers);        // [1, 2, 3, 4, 5] (original array unchanged)\n    console.log(\"Doubled numbers (map):\", doubledNumbers); // [2, 4, 6, 8, 10] (new array)\n\n    // Using forEach() to log each number (no new array returned)\n    let sum = 0;\n    numbers.forEach(num => {\n        sum += num; // Side effect: modifies external variable\n    });\n    console.log(\"Sum (forEach side effect):\", sum); // 15\n    ```\n\n---"],"codeExamples":["const numbers = [1, 2, 3, 4, 5];\n\n    // Using map() to double each number\n    const doubledNumbers = numbers.map(num => num * 2);\n    console.log(\"Original numbers:\", numbers);        // [1, 2, 3, 4, 5] (original array unchanged)\n    console.log(\"Doubled numbers (map):\", doubledNumbers); // [2, 4, 6, 8, 10] (new array)\n\n    // Using forEach() to log each number (no new array returned)\n    let sum = 0;\n    numbers.forEach(num => {\n        sum += num; // Side effect: modifies external variable\n    });\n    console.log(\"Sum (forEach side effect):\", sum); // 15"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Dot vs. Bracket Notation**:\n        *   **Dot Notation (`object.property`):** Properties are accessed directly by their literal name. It's cleaner and generally preferred when the property name is a valid JavaScript identifier and is known at compile time.\n        *   **Bracket Notation (`object[\"property\"]`):** Properties are accessed using a string literal or a variable containing the property name.\n    *   **When to use Bracket Notation**:\n        *   When the property name contains special characters (e.g., spaces, hyphens) that are not valid JavaScript identifiers (e.g., `person[\"first-name\"]`).\n        *   When the property name is stored in a variable or needs to be dynamically determined at runtime (e.g., `let key = \"age\"; person[key]`).\n        *   When accessing array-like objects where keys are numerical strings.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const user = {\n        name: \"Alice\",\n        age: 28\n    };\n\n    // 1. Adding a property\n    user.email = \"alice@example.com\"; // Dot notation\n    user[\"city\"] = \"New York\";         // Bracket notation\n    console.log(\"After adding:\", user);\n    // Output: { name: 'Alice', age: 28, email: 'alice@example.com', city: 'New York' }\n\n    // 2. Modifying a property\n    user.age = 29;                     // Dot notation\n    user[\"city\"] = \"San Francisco\";    // Bracket notation\n    console.log(\"After modifying:\", user);\n    // Output: { name: 'Alice', age: 29, email: 'alice@example.com', city: 'San Francisco' }\n\n    // 3. Deleting a property\n    delete user.email;                 // Deletes 'email'\n    console.log(\"After deleting email:\", user);\n    // Output: { name: 'Alice', age: 29, city: 'San Francisco' }\n\n    // Example for when to use bracket notation\n    let dynamicKey = \"occupation\";\n    user[dynamicKey] = \"Software Engineer\"; // Add 'occupation' dynamically\n    console.log(\"After dynamic add:\", user);\n\n    const data = {\n        \"user-id\": \"12345\",\n        \"first name\": \"Bob\"\n    };\n    console.log(data[\"user-id\"]); // Must use bracket notation for \"user-id\"\n    console.log(data[\"first name\"]); // Must use bracket notation for \"first name\"\n    ```\n\n---"],"codeExamples":["const user = {\n        name: \"Alice\",\n        age: 28\n    };\n\n    // 1. Adding a property\n    user.email = \"alice@example.com\"; // Dot notation\n    user[\"city\"] = \"New York\";         // Bracket notation\n    console.log(\"After adding:\", user);\n    // Output: { name: 'Alice', age: 28, email: 'alice@example.com', city: 'New York' }\n\n    // 2. Modifying a property\n    user.age = 29;                     // Dot notation\n    user[\"city\"] = \"San Francisco\";    // Bracket notation\n    console.log(\"After modifying:\", user);\n    // Output: { name: 'Alice', age: 29, email: 'alice@example.com', city: 'San Francisco' }\n\n    // 3. Deleting a property\n    delete user.email;                 // Deletes 'email'\n    console.log(\"After deleting email:\", user);\n    // Output: { name: 'Alice', age: 29, city: 'San Francisco' }\n\n    // Example for when to use bracket notation\n    let dynamicKey = \"occupation\";\n    user[dynamicKey] = \"Software Engineer\"; // Add 'occupation' dynamically\n    console.log(\"After dynamic add:\", user);\n\n    const data = {\n        \"user-id\": \"12345\",\n        \"first name\": \"Bob\"\n    };\n    console.log(data[\"user-id\"]); // Must use bracket notation for \"user-id\"\n    console.log(data[\"first name\"]); // Must use bracket notation for \"first name\""]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Callback Hell**: This refers to the situation where multiple nested callback functions make code difficult to read, understand, and maintain. It often arises when dealing with sequential asynchronous operations that depend on the results of previous ones, leading to deeply indented code. It can be mitigated by using Promises, `async/await`, or named functions to flatten the code structure.\n    *   **Not Exclusively Callbacks**: While callbacks are a core mechanism for asynchronous operations, modern JavaScript heavily relies on Promises and the `async/await` syntax, which are built on top of callbacks but provide a more structured and readable way to handle asynchronous flows, especially for sequential or parallel operations.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Simple callback with setTimeout\n    console.log(\"Start of script\");\n\n    function greetUser(name, callback) {\n        setTimeout(function() { // This is the asynchronous operation\n            const message = `Hello, ${name}!`;\n            callback(message); // The callback is executed after the delay\n        }, 2000); // 2-second delay\n    }\n\n    // Calling greetUser with an anonymous callback function\n    greetUser(\"Alice\", function(greetingMessage) {\n        console.log(greetingMessage); // This will log after 2 seconds\n    });\n\n    console.log(\"End of script (continues immediately)\");\n    // Expected output order:\n    // Start of script\n    // End of script (continues immediately)\n    // Hello, Alice! (after 2 seconds)\n    ```\n\n---"],"codeExamples":["// Simple callback with setTimeout\n    console.log(\"Start of script\");\n\n    function greetUser(name, callback) {\n        setTimeout(function() { // This is the asynchronous operation\n            const message = `Hello, ${name}!`;\n            callback(message); // The callback is executed after the delay\n        }, 2000); // 2-second delay\n    }\n\n    // Calling greetUser with an anonymous callback function\n    greetUser(\"Alice\", function(greetingMessage) {\n        console.log(greetingMessage); // This will log after 2 seconds\n    });\n\n    console.log(\"End of script (continues immediately)\");\n    // Expected output order:\n    // Start of script\n    // End of script (continues immediately)\n    // Hello, Alice! (after 2 seconds)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **`Object.prototype`**: `Object.prototype` is the base object that sits at the top of almost every prototype chain in JavaScript. Most objects ultimately inherit from `Object.prototype`. It contains common methods like `toString()`, `hasOwnProperty()`, `isPrototypeOf()`, etc., which are then available to all objects down the chain. It marks the end of a typical prototype chain (its own `[[Prototype]]` is `null`).\n    *   **Checking Own Property**: You can use the `hasOwnProperty()` method, which is inherited from `Object.prototype`. This method returns `true` if the object has the specified property as its own direct property (not inherited), and `false` otherwise.\n        ```javascript\n        const myObject = { a: 1 };\n        const inheritedObject = Object.create(myObject); // inheritedObject's prototype is myObject\n        inheritedObject.b = 2;\n\n        console.log(inheritedObject.hasOwnProperty('b')); // true\n        console.log(inheritedObject.hasOwnProperty('a')); // false (it's inherited)\n        console.log(myObject.hasOwnProperty('a'));     // true\n        ```\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Define a prototype object\n    const animal = {\n        eats: true,\n        walk() {\n            console.log(\"Animal walks.\");\n        }\n    };\n\n    // Create a new object `rabbit` and set `animal` as its prototype\n    const rabbit = Object.create(animal);\n    rabbit.jumps = true;\n\n    console.log(rabbit.eats); // true (inherited from animal)\n    rabbit.walk();            // Animal walks. (inherited from animal)\n    console.log(rabbit.jumps); // true (own property)\n\n    // Check the prototype chain\n    console.log(Object.getPrototypeOf(rabbit) === animal); // true\n    console.log(Object.getPrototypeOf(animal) === Object.prototype); // true\n    console.log(Object.getPrototypeOf(Object.prototype)); // null (end of chain)\n    ```\n\n---"],"codeExamples":["// Define a prototype object\n    const animal = {\n        eats: true,\n        walk() {\n            console.log(\"Animal walks.\");\n        }\n    };\n\n    // Create a new object `rabbit` and set `animal` as its prototype\n    const rabbit = Object.create(animal);\n    rabbit.jumps = true;\n\n    console.log(rabbit.eats); // true (inherited from animal)\n    rabbit.walk();            // Animal walks. (inherited from animal)\n    console.log(rabbit.jumps); // true (own property)\n\n    // Check the prototype chain\n    console.log(Object.getPrototypeOf(rabbit) === animal); // true\n    console.log(Object.getPrototypeOf(animal) === Object.prototype); // true\n    console.log(Object.getPrototypeOf(Object.prototype)); // null (end of chain)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Practical Applications**:\n        *   **Private Variables/Methods**: Creating private data by encapsulating variables within a closure, exposing only public methods to interact with them (e.g., module pattern).\n        *   **Function Factories**: Functions that generate other functions with specific configurations.\n        *   **Currying**: Transforming a function that takes multiple"],"codeExamples":[]}]},{"day":"Day-09","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, you can assign default values. If the source value is `undefined`, the default value will be used. For example: `const { name = 'Guest' } = user;` or `const [first, second = 0] = myArray;`.\n    *   You can swap values concisely: `[a, b] = [b, a];`.\n    *   Yes, destructuring supports nested structures, allowing you to extract values from deeply nested objects or arrays in a single line.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Array Destructuring\n    const colors = ['red', 'green', 'blue'];\n    const [firstColor, secondColor, thirdColor] = colors;\n    console.log(firstColor);  // Output: red\n\n    // Object Destructuring\n    const person = {\n        name: 'Alice',\n        age: 30,\n        city: 'New York'\n    };\n    const { name, age } = person;\n    console.log(name);    // Output: Alice\n    console.log(age);     // Output: 30\n    ```\n\n---"],"codeExamples":["// Array Destructuring\n    const colors = ['red', 'green', 'blue'];\n    const [firstColor, secondColor, thirdColor] = colors;\n    console.log(firstColor);  // Output: red\n\n    // Object Destructuring\n    const person = {\n        name: 'Alice',\n        age: 30,\n        city: 'New York'\n    };\n    const { name, age } = person;\n    console.log(name);    // Output: Alice\n    console.log(age);     // Output: 30"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, any valid JavaScript expression can be embedded, including variable names, arithmetic operations, function calls, etc.\n    *   It will result in a `SyntaxError: Invalid or unexpected token`. Traditional strings must be on a single line or use `\\n` for new lines.\n    *   Tagged Templates allow you to parse a template literal with a function. The function receives an array of string parts and the values of the interpolated expressions. This is useful for tasks like safely escaping strings, internationalization (i18n), or creating domain-specific languages.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const name = 'Bob';\n    const item = 'laptop';\n    const price = 1200;\n\n    // Traditional concatenation\n    const oldMessage = \"Hello, \" + name + \"! Your \" + item + \" costs $\" + price + \".\";\n    console.log(oldMessage);\n\n    // Using Template Literals\n    const newMessage = `Hello, ${name}! Your ${item} costs $${price}.\n    Thank you for your purchase!`; // Multi-line string\n    console.log(newMessage);\n    ```\n\n---"],"codeExamples":["const name = 'Bob';\n    const item = 'laptop';\n    const price = 1200;\n\n    // Traditional concatenation\n    const oldMessage = \"Hello, \" + name + \"! Your \" + item + \" costs $\" + price + \".\";\n    console.log(oldMessage);\n\n    // Using Template Literals\n    const newMessage = `Hello, ${name}! Your ${item} costs $${price}.\n    Thank you for your purchase!`; // Multi-line string\n    console.log(newMessage);"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `typeof undefined` returns `'undefined'`. `typeof null` unexpectedly returns `'object'` (this is a long-standing bug in JavaScript that was never fixed for backward compatibility).\n    *   Yes, both `null` and `undefined` are among the six explicitly \"falsy\" values in JavaScript (along with `0`, `\"\"`, `NaN`, and `false`).\n    *   Setting a variable to `null` can be beneficial for garbage collection. If you have a variable holding a reference to a large object that is no longer needed, assigning `null` to that variable can help the garbage collector reclaim the memory associated with that object sooner, especially in long-running applications or when dealing with large data structures.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Undefined examples\n    let myVariable;\n    console.log(myVariable); // Output: undefined\n\n    function greet(name) {\n        console.log(`Hello, ${name}!`);\n    }\n    greet(); // Output: Hello, undefined! (name is undefined)\n\n    const obj = {};\n    console.log(obj.nonExistentProperty); // Output: undefined\n\n    // Null example\n    let data = null;\n    console.log(data); // Output: null\n\n    // Comparison\n    console.log(null == undefined); // Output: true\n    console.log(null === undefined); // Output: false\n    ```\n\n---"],"codeExamples":["// Undefined examples\n    let myVariable;\n    console.log(myVariable); // Output: undefined\n\n    function greet(name) {\n        console.log(`Hello, ${name}!`);\n    }\n    greet(); // Output: Hello, undefined! (name is undefined)\n\n    const obj = {};\n    console.log(obj.nonExistentProperty); // Output: undefined\n\n    // Null example\n    let data = null;\n    console.log(data); // Output: null\n\n    // Comparison\n    console.log(null == undefined); // Output: true\n    console.log(null === undefined); // Output: false"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Spread syntax is used when *calling* a function or *creating* an array/object literal (on the right-hand side of an assignment or as arguments). Rest parameters are used in a function's *parameter list* (on the left-hand side of a function definition).\n    *   No, the spread syntax performs a shallow copy. If the array contains objects, only the references to those objects are copied, not the objects themselves. Modifying a nested object in the copied array would also modify it in the original.\n    *   No, a function can only have one rest parameter, and it must be the last parameter in the function definition.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Spread Syntax Example\n    const arr1 = [1, 2, 3];\n    const arr2 = [...arr1, 4, 5]; // Spreading arr1 into arr2\n    console.log(arr2); // Output: [1, 2, 3, 4, 5]\n\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { ...obj1, c: 3 }; // Spreading obj1 into obj2\n    console.log(obj2); // Output: { a: 1, b: 2, c: 3 }\n\n    // Rest Parameters Example\n    function sumAll(...numbers) { // numbers is a rest parameter\n        return numbers.reduce((total, num) => total + num, 0);\n    }\n    console.log(sumAll(1, 2, 3)); // Output: 6\n    console.log(sumAll(10, 20, 30, 40)); // Output: 100\n    ```\n\n---"],"codeExamples":["// Spread Syntax Example\n    const arr1 = [1, 2, 3];\n    const arr2 = [...arr1, 4, 5]; // Spreading arr1 into arr2\n    console.log(arr2); // Output: [1, 2, 3, 4, 5]\n\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { ...obj1, c: 3 }; // Spreading obj1 into obj2\n    console.log(obj2); // Output: { a: 1, b: 2, c: 3 }\n\n    // Rest Parameters Example\n    function sumAll(...numbers) { // numbers is a rest parameter\n        return numbers.reduce((total, num) => total + num, 0);\n    }\n    console.log(sumAll(1, 2, 3)); // Output: 6\n    console.log(sumAll(10, 20, 30, 40)); // Output: 100"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   If no elements satisfy the condition, `filter()` will return an empty array (`[]`).\n    *   No, `filter()` (like `map()` and `reduce()`) is a non-mutating method. It always returns a new array, leaving the original array unchanged.\n    *   Yes, `filter()` returns a new array, which means you can chain other array methods directly onto its result, such as `myArray.filter(...).map(...).reduce(...)`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const numbers = [1, 2, 3, 4, 5, 6];\n\n    // Using filter() to get even numbers\n    const evenNumbers = numbers.filter(num => num % 2 === 0);\n    console.log(evenNumbers); // Output: [2, 4, 6]\n    console.log(numbers);     // Output: [1, 2, 3, 4, 5, 6] (original array unchanged)\n\n    // Compare with map() and forEach()\n    const doubledNumbers = numbers.map(num => num * 2);\n    console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10, 12]\n\n    numbers.forEach(num => console.log(`Number: ${num}`)); // No return value, just side effect\n    ```\n\n---"],"codeExamples":["const numbers = [1, 2, 3, 4, 5, 6];\n\n    // Using filter() to get even numbers\n    const evenNumbers = numbers.filter(num => num % 2 === 0);\n    console.log(evenNumbers); // Output: [2, 4, 6]\n    console.log(numbers);     // Output: [1, 2, 3, 4, 5, 6] (original array unchanged)\n\n    // Compare with map() and forEach()\n    const doubledNumbers = numbers.map(num => num * 2);\n    console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10, 12]\n\n    numbers.forEach(num => console.log(`Number: ${num}`)); // No return value, just side effect"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, Node.js has interoperability features. An ESM module can `import` a CommonJS module, but a CommonJS module cannot directly `require()` an ESM module (though dynamic `import()` can be used). Considerations involve file extensions (`.mjs` for ESM, `.cjs` for CommonJS) and the `\"type\": \"module\"` field in `package.json`.\n    *   Live bindings mean that if an exported variable's value changes in the exporting module, that change is reflected in the importing module. This is useful for things like constants, shared state, or ensuring consistency across modules.\n    *   Synchronous loading would block the main thread of the browser, leading to a frozen UI and poor user experience, especially if modules are large or require network requests. Asynchronous loading allows the browser to continue rendering while modules are fetched and parsed.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // CommonJS (e.g., in Node.js file: myModule.js)\n    // --- myModule.js ---\n    const PI = 3.14159;\n    function add(a, b) {\n        return a + b;\n    }\n    module.exports = { PI, add };\n\n    // --- app.js ---\n    const { PI, add } = require('./myModule');\n    console.log(PI); // 3.14159\n    console.log(add(2, 3)); // 5\n\n    // ES Modules (e.g., in Node.js with \"type\": \"module\" or browser JS file: myESModule.mjs)\n    // --- myESModule.mjs ---\n    export const GREETING = 'Hello, ESM!';\n    export function multiply(a, b) {\n        return a * b;\n    }\n\n    // --- app.mjs ---\n    import { GREETING, multiply } from './myESModule.mjs';\n    console.log(GREETING); // Hello, ESM!\n    console.log(multiply(4, 5)); // 20\n    ```\n\n---"],"codeExamples":["// CommonJS (e.g., in Node.js file: myModule.js)\n    // --- myModule.js ---\n    const PI = 3.14159;\n    function add(a, b) {\n        return a + b;\n    }\n    module.exports = { PI, add };\n\n    // --- app.js ---\n    const { PI, add } = require('./myModule');\n    console.log(PI); // 3.14159\n    console.log(add(2, 3)); // 5\n\n    // ES Modules (e.g., in Node.js with \"type\": \"module\" or browser JS file: myESModule.mjs)\n    // --- myESModule.mjs ---\n    export const GREETING = 'Hello, ESM!';\n    export function multiply(a, b) {\n        return a * b;\n    }\n\n    // --- app.mjs ---\n    import { GREETING, multiply } from './myESModule.mjs';\n    console.log(GREETING); // Hello, ESM!\n    console.log(multiply(4, 5)); // 20"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Strict mode can be applied to an entire script file (by placing `'use strict'` at the very top) or to individual functions (by placing it at the top of the function body). If applied to a function, only that function's code operates in strict mode.\n    *   Yes, `eval()` behaves differently in strict mode. Variables and function declarations inside `eval()`'s strict-mode code are not created in the surrounding scope, which helps prevent name collisions and makes code more predictable.\n    *   Yes, it is highly recommended. Modern JavaScript frameworks and libraries often enforce or implicitly operate in strict mode. It leads to more robust, secure, and performant code by catching common errors early and making JavaScript behavior more predictable.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Undeclared variable (will throw error in strict mode)\n    function strictFunction() {\n        'use strict';\n        // myVar = 10; // This line would throw a ReferenceError in strict mode\n        // console.log(myVar);\n    }\n    // strictFunction();\n\n    // Example 2: 'this' in strict vs non-strict\n    function showThis() {\n        console.log(this);\n    }\n\n    function showThisStrict() {\n        'use strict';\n        console.log(this);\n    }\n\n    showThis();         // Output: <global object like Window or global>\n    showThisStrict();   // Output: undefined\n    ```\n\n---"],"codeExamples":["// Example 1: Undeclared variable (will throw error in strict mode)\n    function strictFunction() {\n        'use strict';\n        // myVar = 10; // This line would throw a ReferenceError in strict mode\n        // console.log(myVar);\n    }\n    // strictFunction();\n\n    // Example 2: 'this' in strict vs non-strict\n    function showThis() {\n        console.log(this);\n    }\n\n    function showThisStrict() {\n        'use strict';\n        console.log(this);\n    }\n\n    showThis();         // Output: <global object like Window or global>\n    showThisStrict();   // Output: undefined"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `Promise.resolve(value)` returns a Promise object that is resolved with the given `value`. It's useful for creating an already-resolved promise. `Promise.reject(reason)` returns a Promise object that is rejected with the given `reason`. Both are useful for converting non-Promise values into Promises or for testing.\n    *   No, a promise can only be settled once (either fulfilled or rejected). Once settled, its state becomes immutable, and any subsequent attempts to resolve or reject it will be ignored.\n    *   Values are propagated through the chain by returning them from the `.then()` callback. The returned value (or a promise) becomes the resolved value for the next `.then()` in the chain. Errors are propagated by throwing an error inside a `.then()` callback or by returning a rejected promise, which is then caught by the nearest `.catch()` handler.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Creating and using a Promise\n    const fetchData = new Promise((resolve, reject) => {\n        const success = true; // Simulate async operation success/failure\n        setTimeout(() => {\n            if (success) {\n                resolve('Data fetched successfully!');\n            } else {\n                reject('Error fetching data.');\n            }\n        }, 1000);\n    });\n\n    fetchData\n        .then(message => {\n            console.log(message); // Output: Data fetched successfully!\n            return 'Processing complete.'; // Pass value to next .then\n        })\n        .then(nextMessage => {\n            console.log(nextMessage); // Output: Processing complete.\n        })\n        .catch(error => {\n            console.error('Caught an error:', error);\n        });\n\n    // Example of a rejected promise\n    const alwaysFails = Promise.reject(new Error('Something went wrong!'));\n    alwaysFails.catch(err => console.error('Caught by alwaysFails:', err.message));\n    ```\n\n---"],"codeExamples":["// Creating and using a Promise\n    const fetchData = new Promise((resolve, reject) => {\n        const success = true; // Simulate async operation success/failure\n        setTimeout(() => {\n            if (success) {\n                resolve('Data fetched successfully!');\n            } else {\n                reject('Error fetching data.');\n            }\n        }, 1000);\n    });\n\n    fetchData\n        .then(message => {\n            console.log(message); // Output: Data fetched successfully!\n            return 'Processing complete.'; // Pass value to next .then\n        })\n        .then(nextMessage => {\n            console.log(nextMessage); // Output: Processing complete.\n        })\n        .catch(error => {\n            console.error('Caught an error:', error);\n        });\n\n    // Example of a rejected promise\n    const alwaysFails = Promise.reject(new Error('Something went wrong!'));\n    alwaysFails.catch(err => console.error('Caught by alwaysFails:', err.message));"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   If an empty iterable is passed to `Promise.all()`, it immediately returns a fulfilled promise with an empty array `[]`. If an empty iterable is passed to `Promise.race()`, it returns a promise that will forever remain pending (it will never settle).\n    *   No, `Promise.all()` does not stop the execution of other promises if one of them rejects. All promises in the iterable will continue to run to completion, but `Promise.all()` itself will settle (reject) as soon as the first promise rejects.\n    *   Yes, `Promise.any()` (ES2021) waits for the first promise to fulfill, ignoring rejections until all promises have rejected. `Promise.allSettled()` (ES2020) waits for all promises to settle (either fulfill or reject) and returns an array of objects describing the outcome of each promise.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const p1 = new Promise(resolve => setTimeout(() => resolve('P1 resolved'), 100));\n    const p2 = new Promise((_, reject) => setTimeout(() => reject('P2 rejected'), 50));\n    const p3 = new Promise(resolve => setTimeout(() => resolve('P3 resolved'), 200));\n\n    // Promise.all() example\n    Promise.all([p1, p3])\n        .then(results => console.log('All resolved:', results)) // Output: All resolved: ['P1 resolved', 'P3 resolved']\n        .catch(error => console.error('All rejected:', error));\n\n    Promise.all([p1, p2, p3])\n        .then(results => console.log('All resolved (with rejection):', results))\n        .catch(error => console.error('All rejected (with rejection):', error)); // Output: All rejected (with rejection): P2 rejected\n\n    // Promise.race() example\n    Promise.race([p1, p2, p3])\n        .then(result => console.log('Race winner:', result))\n        .catch(error => console.error('Race loser:', error)); // Output: Race loser: P2 rejected (because p2 rejected first)\n    ```\n\n---"],"codeExamples":["const p1 = new Promise(resolve => setTimeout(() => resolve('P1 resolved'), 100));\n    const p2 = new Promise((_, reject) => setTimeout(() => reject('P2 rejected'), 50));\n    const p3 = new Promise(resolve => setTimeout(() => resolve('P3 resolved'), 200));\n\n    // Promise.all() example\n    Promise.all([p1, p3])\n        .then(results => console.log('All resolved:', results)) // Output: All resolved: ['P1 resolved', 'P3 resolved']\n        .catch(error => console.error('All rejected:', error));\n\n    Promise.all([p1, p2, p3])\n        .then(results => console.log('All resolved (with rejection):', results))\n        .catch(error => console.error('All rejected (with rejection):', error)); // Output: All rejected (with rejection): P2 rejected\n\n    // Promise.race() example\n    Promise.race([p1, p2, p3])\n        .then(result => console.log('Race winner:', result))\n        .catch(error => console.error('Race loser:', error)); // Output: Race loser: P2 rejected (because p2 rejected first)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":[],"codeExamples":[]}]},{"day":"Day-10","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   You can effectively \"pass an object by value\" by creating a *shallow or deep copy* of the object before passing it to the function. For a shallow copy, you can use `Object.assign({}, originalObj)` or the spread syntax `{...originalObj}` for objects, and `[...originalArray]` for arrays. For a deep copy, you'd typically use a library like Lodash's `cloneDeep` or `JSON.parse(JSON.stringify(originalObj))` (with limitations).\n    *   If you reassign the object parameter itself within the function (e.g., `obj = { newProp: 'value' }`), the parameter will now point to a *new* object. The original variable outside the function will *still point to the original object*, and thus will not be affected by this reassignment.\n    *   This behavior highlights why immutability is important in JavaScript, especially when working with objects. By ensuring that objects are never directly mutated but instead new objects are created for every change, you can avoid unexpected side effects from functions that receive references to your objects.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Pass by Value (Primitives)\n    let num = 10;\n\n    function addFive(value) {\n      value = value + 5; // Modifies the copy\n      console.log(\"Inside function (primitive):\", value); // 15\n    }\n\n    addFive(num);\n    console.log(\"Outside function (primitive):\", num); // 10 (original unaffected)\n\n    // Pass by Value (Objects/References)\n    let myObject = {\n      a: 1,\n      b: 2\n    };\n\n    function modifyObject(obj) {\n      obj.a = 100; // Modifies the object pointed to by the reference\n      obj.c = 3;   // Adds a new property to the object\n      console.log(\"Inside function (object modified):\", obj); // { a: 100, b: 2, c: 3 }\n\n      obj = {\n        x: 1,\n        y: 2\n      }; // Reassigns the local 'obj' parameter to a NEW object\n      console.log(\"Inside function (object reassigned):\", obj); // { x: 1, y: 2 }\n    }\n\n    modifyObject(myObject);\n    console.log(\"Outside function (object):\", myObject); // { a: 100, b: 2, c: 3 } (original object affected by property modifications, but not by reassignment)\n    ```\n\n---"],"codeExamples":["// Pass by Value (Primitives)\n    let num = 10;\n\n    function addFive(value) {\n      value = value + 5; // Modifies the copy\n      console.log(\"Inside function (primitive):\", value); // 15\n    }\n\n    addFive(num);\n    console.log(\"Outside function (primitive):\", num); // 10 (original unaffected)\n\n    // Pass by Value (Objects/References)\n    let myObject = {\n      a: 1,\n      b: 2\n    };\n\n    function modifyObject(obj) {\n      obj.a = 100; // Modifies the object pointed to by the reference\n      obj.c = 3;   // Adds a new property to the object\n      console.log(\"Inside function (object modified):\", obj); // { a: 100, b: 2, c: 3 }\n\n      obj = {\n        x: 1,\n        y: 2\n      }; // Reassigns the local 'obj' parameter to a NEW object\n      console.log(\"Inside function (object reassigned):\", obj); // { x: 1, y: 2 }\n    }\n\n    modifyObject(myObject);\n    console.log(\"Outside function (object):\", myObject); // { a: 100, b: 2, c: 3 } (original object affected by property modifications, but not by reassignment)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   To correctly check if a variable is an array, you should use `Array.isArray()`. For example, `Array.isArray([])` returns `true`, while `Array.isArray({})` returns `false`.\n    *   For more specific object type checking, especially for custom objects or instances of classes, you can use `instanceof` or check the object's `constructor.name`. For example, `myDate instanceof Date` would return `true` if `myDate` is a `Date` object. You can also use `Object.prototype.toString.call(variable)` which returns a string like `\"[object Array]\"`, `\"[object Object]\"`, `\"[object Date]\"`, etc.\n    *   `instanceof` is more useful than `typeof` when you need to determine if an object is an instance of a specific class or constructor function (or any of its superclasses in the prototype chain). `typeof` only tells you the broad category (primitive, object, function), whereas `instanceof` provides more granular information about the object's origin.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log(typeof 42); // \"number\"\n    console.log(typeof \"hello\"); // \"string\"\n    console.log(typeof true); // \"boolean\"\n    console.log(typeof undefined); // \"undefined\"\n    console.log(typeof null); // \"object\" (limitation!)\n    console.log(typeof {}); // \"object\"\n    console.log(typeof []); // \"object\" (limitation!)\n    console.log(typeof function() {}); // \"function\"\n\n    // Correctly checking for an array\n    console.log(Array.isArray([])); // true\n    console.log(Array.isArray({})); // false\n\n    // Using instanceof\n    class MyClass {}\n    const myInstance = new MyClass();\n    const myArr = [];\n    console.log(myInstance instanceof MyClass); // true\n    console.log(myArr instanceof Array); // true\n    console.log(myArr instanceof Object); // true (due to prototype chain)\n    ```\n\n---"],"codeExamples":["console.log(typeof 42); // \"number\"\n    console.log(typeof \"hello\"); // \"string\"\n    console.log(typeof true); // \"boolean\"\n    console.log(typeof undefined); // \"undefined\"\n    console.log(typeof null); // \"object\" (limitation!)\n    console.log(typeof {}); // \"object\"\n    console.log(typeof []); // \"object\" (limitation!)\n    console.log(typeof function() {}); // \"function\"\n\n    // Correctly checking for an array\n    console.log(Array.isArray([])); // true\n    console.log(Array.isArray({})); // false\n\n    // Using instanceof\n    class MyClass {}\n    const myInstance = new MyClass();\n    const myArr = [];\n    console.log(myInstance instanceof MyClass); // true\n    console.log(myArr instanceof Array); // true\n    console.log(myArr instanceof Object); // true (due to prototype chain)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   The global `isNaN()` function has a quirk: it returns `true` for values that are not `NaN` but cannot be coerced into numbers (e.g., `isNaN(\"hello\")` is `true`). `Number.isNaN()` was introduced in ES6 and is a more robust check. It returns `true` only if the value is *actually* the `NaN` value and does *not* perform type coercion. `Number.isNaN()` is generally preferred because it avoids the unexpected behavior of the global `isNaN()` when dealing with non-numeric strings.\n    *   To strictly check if a variable holds the `NaN` value without coercion, you should use `Number.isNaN()`. Alternatively, you can leverage the `NaN !== NaN` property: `value !== value` will only be true if `value` is `NaN`.\n    *   No, `NaN` cannot be used in meaningful comparisons with other numbers. Any comparison operation involving `NaN` (e.g., `NaN > 5`, `NaN < 10`, `NaN === NaN`) will always evaluate to `false`.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Examples where NaN appears\n    console.log(0 / 0); // NaN\n    console.log(Math.sqrt(-1)); // NaN\n    console.log(parseInt(\"hello\")); // NaN\n    console.log(Number(\"abc\")); // NaN\n    console.log(undefined + 5); // NaN\n\n    // Using global isNaN()\n    console.log(isNaN(123)); // false\n    console.log(isNaN(\"hello\")); // true (coerces \"hello\" to NaN)\n    console.log(isNaN(NaN)); // true\n    console.log(isNaN(\"123\")); // false (coerces \"123\" to 123)\n\n    // Using Number.isNaN() (preferred)\n    console.log(Number.isNaN(123)); // false\n    console.log(Number.isNaN(\"hello\")); // false (no coercion, \"hello\" is not NaN)\n    console.log(Number.isNaN(NaN)); // true\n    console.log(Number.isNaN(\"123\")); // false\n    ```\n\n---"],"codeExamples":["// Examples where NaN appears\n    console.log(0 / 0); // NaN\n    console.log(Math.sqrt(-1)); // NaN\n    console.log(parseInt(\"hello\")); // NaN\n    console.log(Number(\"abc\")); // NaN\n    console.log(undefined + 5); // NaN\n\n    // Using global isNaN()\n    console.log(isNaN(123)); // false\n    console.log(isNaN(\"hello\")); // true (coerces \"hello\" to NaN)\n    console.log(isNaN(NaN)); // true\n    console.log(isNaN(\"123\")); // false (coerces \"123\" to 123)\n\n    // Using Number.isNaN() (preferred)\n    console.log(Number.isNaN(123)); // false\n    console.log(Number.isNaN(\"hello\")); // false (no coercion, \"hello\" is not NaN)\n    console.log(Number.isNaN(NaN)); // true\n    console.log(Number.isNaN(\"123\")); // false"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   **Practical Use Cases**:\n        *   **Conditional Execution (`&&`)**: `user && user.isAdmin && grantAdminAccess();` (only calls `grantAdminAccess()` if `user` exists and `user.isAdmin` is true).\n        *   **Default Value Assignment (`||`)**: `const userName = inputName || \"Guest\";` (if `inputName` is falsy, `userName` defaults to \"Guest\").\n        *   **Guarding against errors**: `data && data.items && data.items.length` to avoid errors when trying to access properties of potentially `null` or `undefined` objects.\n    *   **`??` vs `||`**: The nullish coalescing operator (`??`) short-circuits and returns the right-hand operand *only if* the left-hand operand is `null` or `undefined`. In contrast, `||` returns the right-hand operand if the left-hand operand is *any falsy value* (including `0`, `\"\"`, `false`, `NaN`). This makes `??` useful when `0` or `\"\"` are valid values that you don't want to treat as \"missing\" defaults.\n    *   Yes, you can use short-circuiting with functions. If a function call is part of a short-circuiting expression, the function will only be executed if its evaluation is necessary to determine the overall result of the logical operation.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Logical AND (&&) Short-circuiting\n    function logMessage(msg) {\n      console.log(msg);\n      return msg;\n    }\n\n    let user = {\n      name: \"Alice\"\n    };\n    let isAdmin = false;\n\n    // Example 1: `user` is truthy, so `logMessage('User exists')` is executed\n    user && logMessage('User exists'); // Output: \"User exists\"\n\n    // Example 2: `isAdmin` is falsy, so `logMessage('Grant admin access')` is NOT executed\n    isAdmin && logMessage('Grant admin access'); // No output\n\n    // Assigning a value based on short-circuiting\n    const result1 = 0 && \"Hello\";\n    console.log(result1); // 0 (0 is falsy, so it returns 0)\n\n    const result2 = \"World\" && 123;\n    console.log(result2); // 123 (\"World\" is truthy, so it returns 123)\n\n    // Logical OR (||) Short-circuiting\n    let userName = \"\";\n    let defaultName = \"Guest\";\n\n    // Example 1: `userName` is falsy, so `defaultName` is returned\n    const display1 = userName || defaultName;\n    console.log(display1); // \"Guest\"\n\n    let age = 30;\n    // Example 2: `age` is truthy, so `age` is returned, `logMessage` is NOT executed\n    const display2 = age || logMessage(\"Age not found\");\n    console.log(display2); // 30\n\n    // Using `??` for comparison (not short-circuiting example but shows difference)\n    const count = 0;\n    const items = count || \"No items\"; // \"No items\" (0 is falsy)\n    const itemsStrict = count ?? \"No items\"; // 0 (0 is not null/undefined)\n    console.log(items);\n    console.log(itemsStrict);\n    ```\n\n---"],"codeExamples":["// Logical AND (&&) Short-circuiting\n    function logMessage(msg) {\n      console.log(msg);\n      return msg;\n    }\n\n    let user = {\n      name: \"Alice\"\n    };\n    let isAdmin = false;\n\n    // Example 1: `user` is truthy, so `logMessage('User exists')` is executed\n    user && logMessage('User exists'); // Output: \"User exists\"\n\n    // Example 2: `isAdmin` is falsy, so `logMessage('Grant admin access')` is NOT executed\n    isAdmin && logMessage('Grant admin access'); // No output\n\n    // Assigning a value based on short-circuiting\n    const result1 = 0 && \"Hello\";\n    console.log(result1); // 0 (0 is falsy, so it returns 0)\n\n    const result2 = \"World\" && 123;\n    console.log(result2); // 123 (\"World\" is truthy, so it returns 123)\n\n    // Logical OR (||) Short-circuiting\n    let userName = \"\";\n    let defaultName = \"Guest\";\n\n    // Example 1: `userName` is falsy, so `defaultName` is returned\n    const display1 = userName || defaultName;\n    console.log(display1); // \"Guest\"\n\n    let age = 30;\n    // Example 2: `age` is truthy, so `age` is returned, `logMessage` is NOT executed\n    const display2 = age || logMessage(\"Age not found\");\n    console.log(display2); // 30\n\n    // Using `??` for comparison (not short-circuiting example but shows difference)\n    const count = 0;\n    const items = count || \"No items\"; // \"No items\" (0 is falsy)\n    const itemsStrict = count ?? \"No items\"; // 0 (0 is not null/undefined)\n    console.log(items);\n    console.log(itemsStrict);"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   No, you cannot use `await` outside of an `async` function. The `await` keyword pauses the execution of the *enclosing `async` function*. Without an `async` function to pause, `await` would have no context and would result in a `SyntaxError`. (Top-level `await` is available in ES Modules in some environments, but generally, it requires an `async` function).\n    *   Errors within an `async` function are handled using a standard `try...catch` block. If a Promise awaited inside the `try` block rejects, the execution jumps to the `catch` block, allowing you to handle the error gracefully.\n    *   You would still prefer `Promise.all()` when you need to run multiple independent asynchronous operations concurrently and wait for *all of them* to complete successfully before proceeding. `Promise.race()` is useful when you want to execute multiple promises concurrently and only care about the result of the *first one to settle* (resolve or reject). Sequential `await` calls would execute operations one after another, which is less efficient for independent tasks.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Simulating an asynchronous operation\n    function fetchData(id) {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(`Data for ID: ${id}`);\n        }, 1000);\n      });\n    }\n\n    // Using Promises directly\n    function getDataWithPromises() {\n      fetchData(1)\n        .then(data1 => {\n          console.log(data1);\n          return fetchData(2);\n        })\n        .then(data2 => {\n          console.log(data2);\n        })\n        .catch(error => {\n          console.error(\"Error with Promises:\", error);\n        });\n    }\n    // getDataWithPromises();\n\n    // Using async/await\n    async function getDataWithAsyncAwait() {\n      try {\n        console.log(\"Fetching data...\");\n        const data1 = await fetchData(1); // Pauses here until fetchData(1) resolves\n        console.log(data1);\n\n        const data2 = await fetchData(2); // Pauses here until fetchData(2) resolves\n        console.log(data2);\n\n        // Example of error handling\n        // await Promise.reject(\"Something went wrong!\");\n\n        console.log(\"All data fetched.\");\n      } catch (error) {\n        console.error(\"Error with async/await:\", error);\n      }\n    }\n    getDataWithAsyncAwait();\n    ```\n\n---"],"codeExamples":["// Simulating an asynchronous operation\n    function fetchData(id) {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(`Data for ID: ${id}`);\n        }, 1000);\n      });\n    }\n\n    // Using Promises directly\n    function getDataWithPromises() {\n      fetchData(1)\n        .then(data1 => {\n          console.log(data1);\n          return fetchData(2);\n        })\n        .then(data2 => {\n          console.log(data2);\n        })\n        .catch(error => {\n          console.error(\"Error with Promises:\", error);\n        });\n    }\n    // getDataWithPromises();\n\n    // Using async/await\n    async function getDataWithAsyncAwait() {\n      try {\n        console.log(\"Fetching data...\");\n        const data1 = await fetchData(1); // Pauses here until fetchData(1) resolves\n        console.log(data1);\n\n        const data2 = await fetchData(2); // Pauses here until fetchData(2) resolves\n        console.log(data2);\n\n        // Example of error handling\n        // await Promise.reject(\"Something went wrong!\");\n\n        console.log(\"All data fetched.\");\n      } catch (error) {\n        console.error(\"Error with async/await:\", error);\n      }\n    }\n    getDataWithAsyncAwait();"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, `slice()` can be used to convert an array-like object into a true array. You can do this by calling `Array.prototype.slice.call(arrayLikeObject)` or more commonly in modern JavaScript, by using the spread syntax: `["],"codeExamples":[]}]},{"day":"Day-11","questions":[]},{"day":"Day-12","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, `reduce()` can be used to replicate the functionality of `map()` or `filter()` by having the reducer function return an array and modifying it in each iteration. For `map`, you'd push the transformed `currentValue` into the `accumulator` array. For `filter`, you'd conditionally push the `currentValue`.\n    *   If `reduce()` is called on an empty array without an `initialValue`, it will throw a `TypeError`. If `initialValue` is provided, it will simply return that `initialValue`.\n    *   `reduce()` is suitable when you need to derive a single value from an array, or when you need to process elements sequentially to build up a result that depends on previous calculations. It's concise for tasks like summing numbers, flattening arrays, grouping objects by a property, or building a complex object from an array of data.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Summing all numbers in an array\n    const numbers = [1, 2, 3, 4, 5];\n    const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n    console.log(sum); // Output: 15\n\n    // Example 2: Counting occurrences of items in an array\n    const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\n    const fruitCount = fruits.reduce((count, fruit) => {\n      count[fruit] = (count[fruit] || 0) + 1;\n      return count;\n    }, {});\n    console.log(fruitCount); // Output: { apple: 3, banana: 2, orange: 1 }\n    ```\n\n---"],"codeExamples":["// Example 1: Summing all numbers in an array\n    const numbers = [1, 2, 3, 4, 5];\n    const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n    console.log(sum); // Output: 15\n\n    // Example 2: Counting occurrences of items in an array\n    const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\n    const fruitCount = fruits.reduce((count, fruit) => {\n      count[fruit] = (count[fruit] || 0) + 1;\n      return count;\n    }, {});\n    console.log(fruitCount); // Output: { apple: 3, banana: 2, orange: 1 }"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   No, these methods only return the object's *own* properties and do not include properties inherited from its prototype chain.\n    *   \"Enumerable\" properties are those that can be iterated over using a `for...in` loop or returned by `Object.keys()`, `Object.values()`, `Object.entries()`. Most properties created directly on an object are enumerable by default, but they can be made non-enumerable using `Object.defineProperty()`.\n    *   You would typically use `Object.entries()` combined with a `for...of` loop to iterate over both keys and values: `for (const [key, value] of Object.entries(myObject)) { /* ... */ }`.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    const user = {\n      name: 'Alice',\n      age: 30,\n      city: 'New York'\n    };\n\n    console.log(Object.keys(user));   // Output: ['name', 'age', 'city']\n    console.log(Object.values(user)); // Output: ['Alice', 30, 'New York']\n    console.log(Object.entries(user)); // Output: [['name', 'Alice'], ['age', 30], ['city', 'New York']]\n\n    // Iterating with Object.entries\n    for (const [key, value] of Object.entries(user)) {\n      console.log(`${key}: ${value}`);\n    }\n    // Output:\n    // name: Alice\n    // age: 30\n    // city: New York\n    ```\n\n---"],"codeExamples":["const user = {\n      name: 'Alice',\n      age: 30,\n      city: 'New York'\n    };\n\n    console.log(Object.keys(user));   // Output: ['name', 'age', 'city']\n    console.log(Object.values(user)); // Output: ['Alice', 30, 'New York']\n    console.log(Object.entries(user)); // Output: [['name', 'Alice'], ['age', 30], ['city', 'New York']]\n\n    // Iterating with Object.entries\n    for (const [key, value] of Object.entries(user)) {\n      console.log(`${key}: ${value}`);\n    }\n    // Output:\n    // name: Alice\n    // age: 30\n    // city: New York"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Yes, both `indexOf()` and `includes()` are case-sensitive. For example, `'Hello'.includes('hello')` would return `false`.\n    *   To check if a string starts with a substring, you'd use `String.prototype.startsWith()`. To check if it ends with a substring, you'd use `String.prototype.endsWith()`. Both are ES6 additions.\n    *   Yes, `indexOf()` returns `0` for a match at the beginning of the string, and `-1` for no match. Since `0` is a truthy value in a boolean context (unless explicitly compared to `-1`), you typically check `myString.indexOf('sub') !== -1` to determine existence, which is why `includes()` was introduced for clarity.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    const sentence = \"The quick brown fox jumps over the lazy dog.\";\n\n    // Using indexOf()\n    console.log(sentence.indexOf('fox'));    // Output: 16 (index of 'f')\n    console.log(sentence.indexOf('cat'));    // Output: -1 (not found)\n    console.log(sentence.indexOf('o', 10));  // Output: 17 (first 'o' after index 10)\n\n    // Using includes()\n    console.log(sentence.includes('jumps')); // Output: true\n    console.log(sentence.includes('zebra')); // Output: false\n    console.log(sentence.includes('quick', 5)); // Output: false (starts searching from index 5, 'quick' is before that)\n    ```\n\n---"],"codeExamples":["const sentence = \"The quick brown fox jumps over the lazy dog.\";\n\n    // Using indexOf()\n    console.log(sentence.indexOf('fox'));    // Output: 16 (index of 'f')\n    console.log(sentence.indexOf('cat'));    // Output: -1 (not found)\n    console.log(sentence.indexOf('o', 10));  // Output: 17 (first 'o' after index 10)\n\n    // Using includes()\n    console.log(sentence.includes('jumps')); // Output: true\n    console.log(sentence.includes('zebra')); // Output: false\n    console.log(sentence.includes('quick', 5)); // Output: false (starts searching from index 5, 'quick' is before that)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Asynchronous `fs` functions are recommended because they are non-blocking. When an asynchronous operation (like reading a file) is initiated, Node.js offloads it and continues executing other code. Once the operation completes, a callback function is triggered. Synchronous operations, however, block the entire Node.js process until they are complete, which can lead to performance issues and unresponsive applications, especially in a server environment.\n    *   With `fs.readFile()`, errors are typically handled as the first argument in the callback function. If an error occurs (e.g., file not found, permission denied), the `err` parameter will contain an `Error` object; otherwise, it will be `null`.\n    *   Common use cases include reading configuration files, logging application events to files, serving static assets (like HTML, CSS, images) directly from the file system, or processing user-uploaded files.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Assuming a file named 'example.txt' exists in the same directory with some content.\n    // example.txt content: \"Hello, Node.js File System!\"\n\n    const fs = require('fs');\n\n    // Asynchronous file read using a callback\n    fs.readFile('example.txt', 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading file:', err);\n        return;\n      }\n      console.log('File content (callback):', data);\n    });\n\n    // Asynchronous file read using Promises (modern approach, often with async/await)\n    fs.promises.readFile('example.txt', 'utf8')\n      .then(data => {\n        console.log('File content (promise):', data);\n      })\n      .catch(err => {\n        console.error('Error reading file (promise):', err);\n      });\n\n    console.log(\"This will log before the file content, demonstrating non-blocking I/O.\");\n    ```\n\n---"],"codeExamples":["// Assuming a file named 'example.txt' exists in the same directory with some content.\n    // example.txt content: \"Hello, Node.js File System!\"\n\n    const fs = require('fs');\n\n    // Asynchronous file read using a callback\n    fs.readFile('example.txt', 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading file:', err);\n        return;\n      }\n      console.log('File content (callback):', data);\n    });\n\n    // Asynchronous file read using Promises (modern approach, often with async/await)\n    fs.promises.readFile('example.txt', 'utf8')\n      .then(data => {\n        console.log('File content (promise):', data);\n      })\n      .catch(err => {\n        console.error('Error reading file (promise):', err);\n      });\n\n    console.log(\"This will log before the file content, demonstrating non-blocking I/O.\");"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   You would choose `bind()` when you want to create a new function with a pre-set `this` context that can be executed later, often as an event handler, a callback function, or when passing a method to another function where its `this` context might otherwise be lost (e.g., in `setTimeout`).\n    *   No, once a function's `this` context is bound using `bind()`, it cannot be changed again, even if you try to use `call()` or `apply()` on the bound function. It's permanently fixed.\n    *   In non-strict mode, if `null` or `undefined` is passed as `thisArg`, `this` will default to the global object (`window` in browsers, `global` or `undefined` in Node.js depending on context). In strict mode, `this` will remain exactly `null` or `undefined` as passed.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    const person = {\n      name: 'Alice',\n      greet: function(greeting, punctuation) {\n        console.log(`${greeting}, my name is ${this.name}${punctuation}`);\n      }\n    };\n\n    const anotherPerson = {\n      name: 'Bob'\n    };\n\n    // Using call(): Executes immediately, arguments individually\n    person.greet.call(anotherPerson, 'Hi', '!'); // Output: Hi, my name is Bob!\n\n    // Using apply(): Executes immediately, arguments as an array\n    person.greet.apply(anotherPerson, ['Hello', '.']); // Output: Hello, my name is Bob.\n\n    // Using bind(): Returns a new function, doesn't execute immediately\n    const greetBob = person.greet.bind(anotherPerson, 'Hey');\n    greetBob('?'); // Output: Hey, my name is Bob?\n\n    // Example of bind for event handlers (common use case)\n    // document.getElementById('myButton').addEventListener('click', person.greet.bind(person, 'Hello', '!'));\n    ```\n\n---"],"codeExamples":["const person = {\n      name: 'Alice',\n      greet: function(greeting, punctuation) {\n        console.log(`${greeting}, my name is ${this.name}${punctuation}`);\n      }\n    };\n\n    const anotherPerson = {\n      name: 'Bob'\n    };\n\n    // Using call(): Executes immediately, arguments individually\n    person.greet.call(anotherPerson, 'Hi', '!'); // Output: Hi, my name is Bob!\n\n    // Using apply(): Executes immediately, arguments as an array\n    person.greet.apply(anotherPerson, ['Hello', '.']); // Output: Hello, my name is Bob.\n\n    // Using bind(): Returns a new function, doesn't execute immediately\n    const greetBob = person.greet.bind(anotherPerson, 'Hey');\n    greetBob('?'); // Output: Hey, my name is Bob?\n\n    // Example of bind for event handlers (common use case)\n    // document.getElementById('myButton').addEventListener('click', person.greet.bind(person, 'Hello', '!'));"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":[],"codeExamples":[]}]},{"day":"Day-13","questions":[]},{"day":"Day-14","questions":[]},{"day":"Day-15","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `JSON.stringify()` will omit functions, `undefined`, and `Symbol` values when they are properties of an object. If a function or `undefined` is the value being stringified on its own (not as a property), it will return `undefined`.\n    *   Yes, `JSON.parse()` can throw a `SyntaxError` if the input string is not valid JSON. For example, if it contains trailing commas, unquoted keys, or invalid characters.\n    *   JSON is popular because it is human-readable, lightweight, and easily parsable by machines. It's language-independent, making it ideal for data exchange between different programming languages and systems.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const user = {\n        name: \"Alice\",\n        age: 30,\n        isAdmin: false,\n        greet: () => console.log(\"Hello!\") // This will be omitted\n    };\n\n    // Stringify\n    const jsonString = JSON.stringify(user);\n    console.log(jsonString); // Output: {\"name\":\"Alice\",\"age\":30,\"isAdmin\":false}\n\n    // Parse\n    const parsedUser = JSON.parse(jsonString);\n    console.log(parsedUser.name); // Output: Alice\n\n    // Example of JSON.parse() error\n    try {\n        JSON.parse('{ \"name\": \"Bob\", }'); // Invalid JSON (trailing comma)\n    } catch (e) {\n        console.error(\"Parse error:\", e.message); // Output: Parse error: Unexpected token } in JSON at position 18\n    }\n    ```"],"codeExamples":["const user = {\n        name: \"Alice\",\n        age: 30,\n        isAdmin: false,\n        greet: () => console.log(\"Hello!\") // This will be omitted\n    };\n\n    // Stringify\n    const jsonString = JSON.stringify(user);\n    console.log(jsonString); // Output: {\"name\":\"Alice\",\"age\":30,\"isAdmin\":false}\n\n    // Parse\n    const parsedUser = JSON.parse(jsonString);\n    console.log(parsedUser.name); // Output: Alice\n\n    // Example of JSON.parse() error\n    try {\n        JSON.parse('{ \"name\": \"Bob\", }'); // Invalid JSON (trailing comma)\n    } catch (e) {\n        console.error(\"Parse error:\", e.message); // Output: Parse error: Unexpected token } in JSON at position 18\n    }"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `dependencies` are packages required for the application to run in production. `devDependencies` are packages only needed for development and testing (e.g., testing frameworks, build tools, linters).\n    *   `npm install` installs dependencies based on `package.json` and updates `package-lock.json`. `npm ci` (clean install) installs dependencies strictly based on `package-lock.json`, ensuring consistent builds, and will fail if `package.json` and `package-lock.json` are out of sync. It's often preferred in CI/CD environments.\n    *   The `scripts` field defines command-line scripts that can be run using `npm run <script-name>`. Common examples include `start`, `test`, `build`, etc.\n5.  **Code Example(s)**:\n\n    ```json\n    {\n      \"name\": \"my-node-app\",\n      \"version\": \"1.0.0\",\n      \"description\": \"A simple Node.js application\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\",\n        \"dev\": \"nodemon index.js\"\n      },\n      \"keywords\": [\"node\", \"express\"],\n      \"author\": \"Your Name\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"express\": \"^4.17.1\"\n      },\n      \"devDependencies\": {\n        \"jest\": \"^27.0.6\",\n        \"nodemon\": \"^2.0.12\"\n      }\n    }\n    ```"],"codeExamples":["{\n      \"name\": \"my-node-app\",\n      \"version\": \"1.0.0\",\n      \"description\": \"A simple Node.js application\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\",\n        \"dev\": \"nodemon index.js\"\n      },\n      \"keywords\": [\"node\", \"express\"],\n      \"author\": \"Your Name\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"express\": \"^4.17.1\"\n      },\n      \"devDependencies\": {\n        \"jest\": \"^27.0.6\",\n        \"nodemon\": \"^2.0.12\"\n      }\n    }"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   To create a deep copy of an object, you can use `JSON.parse(JSON.stringify(obj))` (with limitations like losing functions, dates, etc.) or more robust libraries like Lodash's `_.cloneDeep()`. Manually, you'd recursively copy all nested objects and arrays.\n    *   Strings are primitive types in JavaScript. This means that string methods (like `toUpperCase()`, `slice()`) do not modify the original string but return a *new* string. The original string remains unchanged.\n    *   \"Immutable\" means that once a primitive value is created, it cannot be changed. If you perform an operation that seems to change a primitive (e.g., `let x = 5; x = 10;`), you are not changing the original `5`; you are simply assigning a *new* value (`10`) to the variable `x`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Primitive Example\n    let a = 10;\n    let b = a; // b gets a copy of the value 10\n    b = 20;\n    console.log(a); // Output: 10 (a is unaffected)\n    console.log(b); // Output: 20\n\n    // Object Example\n    let obj1 = { value: 10 };\n    let obj2 = obj1; // obj2 gets a reference to the same object as obj1\n    obj2.value = 20;\n    console.log(obj1.value); // Output: 20 (obj1 is affected because they point to the same object)\n    console.log(obj2.value); // Output: 20\n    ```"],"codeExamples":["// Primitive Example\n    let a = 10;\n    let b = a; // b gets a copy of the value 10\n    b = 20;\n    console.log(a); // Output: 10 (a is unaffected)\n    console.log(b); // Output: 20\n\n    // Object Example\n    let obj1 = { value: 10 };\n    let obj2 = obj1; // obj2 gets a reference to the same object as obj1\n    obj2.value = 20;\n    console.log(obj1.value); // Output: 20 (obj1 is affected because they point to the same object)\n    console.log(obj2.value); // Output: 20"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   In production, log management systems or monitoring tools often differentiate between `stdout` and `stderr`. Directing errors to `stderr` allows these tools to easily filter, collect, and alert on actual error conditions, separating them from regular application output.\n    *   Yes, other useful `console` methods include `console.warn()` for warnings, `console.info()` for informational messages, `console.debug()` for detailed debug messages, `console.table()` for displaying tabular data, and `console.time()`/`console.timeEnd()` for measuring execution time.\n    *   No, `console.error()` itself does not stop the execution of your program. It merely logs a message to the error stream. Program execution continues unless an unhandled error or exception occurs elsewhere.\n5.  **Code Example(s)**:\n\n    ```javascript\n    function divide(a, b) {\n        if (b === 0) {\n            console.error(\"Error: Division by zero is not allowed.\");\n            return NaN;\n        }\n        console.log(`Result of ${a} / ${b}:`);\n        return a / b;\n    }\n\n    console.log(divide(10, 2)); // Logs \"Result of 10 / 2:\" to stdout, then 5\n    console.log(divide(10, 0)); // Logs \"Error: Division by zero is not allowed.\" to stderr, then NaN\n    ```"],"codeExamples":["function divide(a, b) {\n        if (b === 0) {\n            console.error(\"Error: Division by zero is not allowed.\");\n            return NaN;\n        }\n        console.log(`Result of ${a} / ${b}:`);\n        return a / b;\n    }\n\n    console.log(divide(10, 2)); // Logs \"Result of 10 / 2:\" to stdout, then 5\n    console.log(divide(10, 0)); // Logs \"Error: Division by zero is not allowed.\" to stderr, then NaN"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   To add: `mySet.add(value)`. To remove: `mySet.delete(value)`. You can also check for existence with `mySet.has(value)` and clear all elements with `mySet.clear()`.\n    *   `Map` objects are directly iterable using `for...of` loops, and they maintain insertion order. You can iterate over `[key, value]` pairs using `map.entries()`, keys using `map.keys()`, or values using `map.values()`. Plain objects require methods like `Object.keys()`, `Object.values()`, or `Object.entries()` to iterate, and their key order is not guaranteed (though modern JS engines generally preserve insertion order for string/symbol keys).\n    *   Yes, both `Set` and `Map` can store `null` and `undefined` as values. `Map` can also use `null` and `undefined` as keys.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Set Example: Removing duplicates\n    const numbers = [1, 2, 3, 2, 4, 1, 5];\n    const uniqueNumbers = new Set(numbers);\n    console.log([...uniqueNumbers]); // Output: [1, 2, 3, 4, 5]\n\n    // Map Example: Storing user data with user IDs (numbers) as keys\n    const userMap = new Map();\n    userMap.set(101, { name: \"Alice\", email: \"alice@example.com\" });\n    userMap.set(102, { name: \"Bob\", email: \"bob@example.com\" });\n    console.log(userMap.get(101)); // Output: { name: 'Alice', email: 'alice@example.com' }\n\n    // Iterating over a Map\n    for (const [id, userData] of userMap) {\n        console.log(`User ID: ${id}, Name: ${userData.name}`);\n    }\n    // Output:\n    // User ID: 101, Name: Alice\n    // User ID: 102, Name: Bob\n    ```"],"codeExamples":["// Set Example: Removing duplicates\n    const numbers = [1, 2, 3, 2, 4, 1, 5];\n    const uniqueNumbers = new Set(numbers);\n    console.log([...uniqueNumbers]); // Output: [1, 2, 3, 4, 5]\n\n    // Map Example: Storing user data with user IDs (numbers) as keys\n    const userMap = new Map();\n    userMap.set(101, { name: \"Alice\", email: \"alice@example.com\" });\n    userMap.set(102, { name: \"Bob\", email: \"bob@example.com\" });\n    console.log(userMap.get(101)); // Output: { name: 'Alice', email: 'alice@example.com' }\n\n    // Iterating over a Map\n    for (const [id, userData] of userMap) {\n        console.log(`User ID: ${id}, Name: ${userData.name}`);\n    }\n    // Output:\n    // User ID: 101, Name: Alice\n    // User ID: 102, Name: Bob"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Asynchronous programming is fundamental to Node.js because it allows Node.js to handle many concurrent operations (like I/O requests, database queries, network calls) efficiently without blocking the single-threaded event loop. This enables Node.js to be highly scalable and performant for I/O-bound tasks.\n    *   Common asynchronous patterns include Callbacks (older), Promises (modern standard), and `async`/`await` (syntactic sugar over Promises, making asynchronous code look synchronous).\n    *   You cannot inherently make a truly synchronous operation asynchronous, as its blocking nature is inherent to its design. However, you can *wrap* a synchronous operation within an asynchronous construct (like a Promise or `setTimeout`) to defer its execution or handle its result asynchronously, but the underlying synchronous work still blocks the thread for its duration. In Node.js, for CPU-bound synchronous tasks, you might use Worker Threads to offload them from the main thread.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Synchronous Example\n    console.log(\"Start synchronous operation.\");\n    function multiply(a, b) {\n        let result = a * b; // This calculation happens immediately and blocks until done\n        return result;\n    }\n    const syncResult = multiply(5, 10);\n    console.log(\"Synchronous result:\", syncResult);\n    console.log(\"End synchronous operation.\");\n\n    // Asynchronous Example\n    console.log(\"Start asynchronous operation.\");\n    setTimeout(() => {\n        console.log(\"Asynchronous operation completed after 2 seconds.\");\n    }, 2000); // This function runs after 2 seconds, but doesn't block\n    console.log(\"This line runs immediately, before the async operation completes.\");\n    console.log(\"End of script execution (main thread continues).\");\n    ```"],"codeExamples":["// Synchronous Example\n    console.log(\"Start synchronous operation.\");\n    function multiply(a, b) {\n        let result = a * b; // This calculation happens immediately and blocks until done\n        return result;\n    }\n    const syncResult = multiply(5, 10);\n    console.log(\"Synchronous result:\", syncResult);\n    console.log(\"End synchronous operation.\");\n\n    // Asynchronous Example\n    console.log(\"Start asynchronous operation.\");\n    setTimeout(() => {\n        console.log(\"Asynchronous operation completed after 2 seconds.\");\n    }, 2000); // This function runs after 2 seconds, but doesn't block\n    console.log(\"This line runs immediately, before the async operation completes.\");\n    console.log(\"End of script execution (main thread continues).\");"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `process.cwd()` returns the current working directory from which the Node.js process was launched. This can vary depending on where the user executes the command. `__dirname` and `__filename`, however, always refer to the location of the script itself, providing a stable and reliable base for resolving relative paths within your project structure.\n    *   No, `__dirname` and `__filename` are CommonJS-specific globals and are not directly available in ES Modules. In ES Modules, you can get similar information using `import.meta.url`. You would then use Node.js's `url` module (`fileURLToPath`) and `path` module (`dirname`) to derive the directory and filename.\n    *   No, the values of `__dirname` and `__filename` are determined at the time the module is loaded and remain constant throughout the script's execution.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Assume this file is located at /home/user/my-project/src/app.js\n\n    console.log('Current directory (from script location):', __dirname);\n    // Expected output: /home/user/my-project/src\n\n    console.log('Current file path:', __filename);\n    // Expected output: /home/user/my-project/src/app.js\n\n    // Example of using __dirname to read a file relative to the script\n    const path = require('path');\n    const fs = require('fs');\n\n    const configFilePath = path.join(__dirname, '..', 'config.json');\n    // This will correctly point to /home/user/my-project/config.json\n    console.log('Constructed config path:', configFilePath);\n\n    // Example of reading a file (synchronously for simplicity)\n    try {\n        const configContent = fs.readFileSync(configFilePath, 'utf8');\n        console.log('Config content:', configContent.substring(0, 20) + '...'); // show first 20 chars\n    } catch (error) {\n        console.error('Error reading config file:', error.message);\n    }\n    ```"],"codeExamples":["// Assume this file is located at /home/user/my-project/src/app.js\n\n    console.log('Current directory (from script location):', __dirname);\n    // Expected output: /home/user/my-project/src\n\n    console.log('Current file path:', __filename);\n    // Expected output: /home/user/my-project/src/app.js\n\n    // Example of using __dirname to read a file relative to the script\n    const path = require('path');\n    const fs = require('fs');\n\n    const configFilePath = path.join(__dirname, '..', 'config.json');\n    // This will correctly point to /home/user/my-project/config.json\n    console.log('Constructed config path:', configFilePath);\n\n    // Example of reading a file (synchronously for simplicity)\n    try {\n        const configContent = fs.readFileSync(configFilePath, 'utf8');\n        console.log('Config content:', configContent.substring(0, 20) + '...'); // show first 20 chars\n    } catch (error) {\n        console.error('Error reading config file:', error.message);\n    }"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   A \"stack overflow\" error occurs when a recursive function calls itself too many times without reaching a base case, leading to the call stack exceeding its maximum limit. Each function call adds a new frame to the call stack, and too many frames exhaust the available memory.\n    *   An iterative solution is often preferred when performance is critical, or when dealing with very deep recursion that might lead to stack overflows. Iterative solutions generally consume less memory (no call stack buildup) and can sometimes be more performant, though recursive solutions can be more elegant and readable for certain problems.\n    *   You can optimize recursive functions using techniques like **memoization** (caching results of expensive function calls to avoid recalculating them) or **tail call optimization (TCO)**. While TCO is part of the ES6 specification, JavaScript engines don't widely implement it for general recursion, so it's not a reliable optimization in practice unless specifically targeting environments that support it. For deep recursion in Node.js, converting to an iterative approach or using Worker Threads might be necessary.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Recursive function to calculate factorial\n    function factorial(n) {\n        // Base case: if n is 0 or 1, factorial is 1\n        if (n === 0 || n === 1) {\n            return 1;\n        }\n        // Recursive step: n * factorial(n - 1)\n        return n * factorial(n - 1);\n    }\n\n    console.log(\"Factorial of 5:\", factorial(5)); // Output: 120 (5 * 4 * 3 * 2 * 1)\n    console.log(\"Factorial of 0:\", factorial(0)); // Output: 1\n\n    // Example of potential stack overflow (don't run with large numbers in production)\n    // console.log(factorial(100000)); // This would likely cause a stack overflow\n    ```"],"codeExamples":["// Recursive function to calculate factorial\n    function factorial(n) {\n        // Base case: if n is 0 or 1, factorial is 1\n        if (n === 0 || n === 1) {\n            return 1;\n        }\n        // Recursive step: n * factorial(n - 1)\n        return n * factorial(n - 1);\n    }\n\n    console.log(\"Factorial of 5:\", factorial(5)); // Output: 120 (5 * 4 * 3 * 2 * 1)\n    console.log(\"Factorial of 0:\", factorial(0)); // Output: 1\n\n    // Example of potential stack overflow (don't run with large numbers in production)\n    // console.log(factorial(100000)); // This would likely cause a stack overflow"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `emitter.on(eventName, listener)` registers a listener that will be called *every time* the specified `eventName` is emitted. `emitter.once(eventName, listener)` registers a listener that will be called *only once* when the `eventName` is emitted, and then it's automatically removed.\n    *   You can remove specific event listeners using `emitter.removeListener(eventName, listenerFunction)` (you need a reference to the original function). To remove all listeners for a specific event, use `emitter.removeAllListeners(eventName)`. To remove all listeners for all events, use `emitter.removeAllListeners()`.\n    *   By default, `EventEmitter` emits events **synchronously**. All listeners for an event are called in the order they were registered, blocking the execution until all listeners complete. If you need asynchronous behavior (e.g., to prevent blocking the event loop for long-running listeners), you would explicitly make the listener function asynchronous (e.g., using `process.nextTick` or `setImmediate`).\n5.  **Code Example(s)**:\n\n    ```javascript\n    const EventEmitter = require('events');\n\n    // Create a new instance of EventEmitter\n    class MyLogger extends EventEmitter {\n        log(message) {\n            console.log(`Log: ${message}`);\n            this.emit('messageLogged', message, Date.now()); // Emit an event\n        }\n\n        error(err) {\n            console.error(`Error: ${err}`);\n            this.emit('error', err); // Emit an error event\n        }\n    }\n\n    const logger = new MyLogger();\n\n    // Register a listener for 'messageLogged' event\n    logger.on('messageLogged', (msg, timestamp) => {\n        console.log(`Listener 1: Message \"${msg}\" logged at ${new Date(timestamp).toLocaleTimeString()}`);\n    });\n\n    // Register another listener for 'messageLogged' event\n    logger.on('messageLogged', (msg) => {\n        console.log(`Listener 2: Acknowledged message: ${msg.toUpperCase()}`);\n    });\n\n    // Register a listener that only fires once for 'error' event\n    logger.once('error', (err) => {\n        console.log(`First and only error caught: ${err}`);\n    });\n\n    // Emit events\n    logger.log('User logged in');\n    logger.log('Data saved successfully');\n    logger.error('Database connection failed!');\n    logger.error('Another error (this listener won't fire)'); // The 'once' listener won't catch this\n    ```"],"codeExamples":["const EventEmitter = require('events');\n\n    // Create a new instance of EventEmitter\n    class MyLogger extends EventEmitter {\n        log(message) {\n            console.log(`Log: ${message}`);\n            this.emit('messageLogged', message, Date.now()); // Emit an event\n        }\n\n        error(err) {\n            console.error(`Error: ${err}`);\n            this.emit('error', err); // Emit an error event\n        }\n    }\n\n    const logger = new MyLogger();\n\n    // Register a listener for 'messageLogged' event\n    logger.on('messageLogged', (msg, timestamp) => {\n        console.log(`Listener 1: Message \"${msg}\" logged at ${new Date(timestamp).toLocaleTimeString()}`);\n    });\n\n    // Register another listener for 'messageLogged' event\n    logger.on('messageLogged', (msg) => {\n        console.log(`Listener 2: Acknowledged message: ${msg.toUpperCase()}`);\n    });\n\n    // Register a listener that only fires once for 'error' event\n    logger.once('error', (err) => {\n        console.log(`First and only error caught: ${err}`);\n    });\n\n    // Emit events\n    logger.log('User logged in');\n    logger.log('Data saved successfully');\n    logger.error('Database connection failed!');\n    logger.error('Another error (this listener won't fire)'); // The 'once' listener won't catch this"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":[],"codeExamples":[]}]},{"day":"Day-16","questions":[{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   No, `Symbol` properties are non-enumerable by default, so they won't appear in `for...in` loops, `Object.keys()`, `Object.values()`, or `Object.entries()`. You can, however, retrieve them using `Object.getOwnPropertySymbols()`.\n    *   `Symbol()` creates a new, unique symbol every time. `Symbol.for(key)`, on the other hand, registers the symbol in a global symbol registry. If a symbol with the given `key` already exists in the registry, it returns that symbol; otherwise, it creates a new one and registers it. This allows symbols to be shared and retrieved across different parts of a codebase.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Use Case: Unique object property keys\n    const id = Symbol('id');\n    const anotherId = Symbol('id');\n\n    const user = {\n        name: 'Alice',\n        [id]: 123, // Use Symbol as a property key\n        age: 30\n    };\n\n    console.log(user[id]); // Output: 123\n    console.log(user[anotherId]); // Output: undefined (because anotherId is a different unique symbol)\n\n    // Symbol properties are not enumerable by default\n    for (let key in user) {\n        console.log(key); // Output: name, age (id is skipped)\n    }\n\n    // Retrieve Symbol properties\n    console.log(Object.getOwnPropertySymbols(user)); // Output: [Symbol(id)]\n    ```\n\n---"],"codeExamples":["// Use Case: Unique object property keys\n    const id = Symbol('id');\n    const anotherId = Symbol('id');\n\n    const user = {\n        name: 'Alice',\n        [id]: 123, // Use Symbol as a property key\n        age: 30\n    };\n\n    console.log(user[id]); // Output: 123\n    console.log(user[anotherId]); // Output: undefined (because anotherId is a different unique symbol)\n\n    // Symbol properties are not enumerable by default\n    for (let key in user) {\n        console.log(key); // Output: name, age (id is skipped)\n    }\n\n    // Retrieve Symbol properties\n    console.log(Object.getOwnPropertySymbols(user)); // Output: [Symbol(id)]"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Currying is a specific form of partial application. Currying transforms a function `f(a, b, c)` into `f(a)(b)(c)`. Partial application, on the other hand, allows you to fix a certain number of arguments to a function and return a new function that takes the remaining arguments, without necessarily breaking it down into single-argument functions (e.g., `f(a,b,c)` could become `f_partial(a)(b,c)` or `f_partial(a,b)(c)`). Currying is always partial application, but partial application is not always currying.\n    *   Downsides include potentially increased verbosity for very simple functions, and it can sometimes make debugging call stacks more complex due to multiple nested function calls. It also adds overhead if not used judiciously.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Non-curried function\n    const add = (a, b, c) => a + b + c;\n    console.log(add(1, 2, 3)); // Output: 6\n\n    // Curried version of the add function\n    const curriedAdd = (a) => {\n        return (b) => {\n            return (c) => {\n                return a + b + c;\n            };\n        };\n    };\n\n    console.log(curriedAdd(1)(2)(3)); // Output: 6\n\n    // Benefits: Partial application\n    const addOne = curriedAdd(1);\n    const addOneAndTwo = addOne(2);\n    console.log(addOneAndTwo(3)); // Output: 6\n\n    const addTen = curriedAdd(10);\n    console.log(addTen(20)(30)); // Output: 60\n    ```\n\n---"],"codeExamples":["// Non-curried function\n    const add = (a, b, c) => a + b + c;\n    console.log(add(1, 2, 3)); // Output: 6\n\n    // Curried version of the add function\n    const curriedAdd = (a) => {\n        return (b) => {\n            return (c) => {\n                return a + b + c;\n            };\n        };\n    };\n\n    console.log(curriedAdd(1)(2)(3)); // Output: 6\n\n    // Benefits: Partial application\n    const addOne = curriedAdd(1);\n    const addOneAndTwo = addOne(2);\n    console.log(addOneAndTwo(3)); // Output: 6\n\n    const addTen = curriedAdd(10);\n    console.log(addTen(20)(30)); // Output: 60"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   `process.nextTick()` callbacks are executed *before* `Promise` microtasks. So the order within a single event loop iteration is generally: current synchronous code -> `process.nextTick()` callbacks -> `Promise.then()`/`async`/`await` callbacks -> `setImmediate()` callbacks -> `setTimeout()` callbacks (if their timers have expired).\n    *   Yes, excessive use of `process.nextTick()` can lead to \"I/O starvation\" or \"event loop starvation.\" Since `nextTick` callbacks run before I/O, a long chain of them can hog the event loop, preventing Node.js from processing I/O events, timers, or other immediate tasks, making the application unresponsive.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log('Start');\n\n    setTimeout(() => {\n        console.log('setTimeout callback');\n    }, 0);\n\n    setImmediate(() => {\n        console.log('setImmediate callback');\n    });\n\n    process.nextTick(() => {\n        console.log('process.nextTick callback');\n    });\n\n    Promise.resolve().then(() => {\n        console.log('Promise.then callback');\n    });\n\n    console.log('End');\n\n    // Expected (common) output order:\n    // Start\n    // End\n    // process.nextTick callback\n    // Promise.then callback\n    // setImmediate callback\n    // setTimeout callback\n    // (Note: setTimeout and setImmediate order can sometimes vary slightly based on system load,\n    // but nextTick and Promise microtasks are consistently before them.)\n    ```\n\n---"],"codeExamples":["console.log('Start');\n\n    setTimeout(() => {\n        console.log('setTimeout callback');\n    }, 0);\n\n    setImmediate(() => {\n        console.log('setImmediate callback');\n    });\n\n    process.nextTick(() => {\n        console.log('process.nextTick callback');\n    });\n\n    Promise.resolve().then(() => {\n        console.log('Promise.then callback');\n    });\n\n    console.log('End');\n\n    // Expected (common) output order:\n    // Start\n    // End\n    // process.nextTick callback\n    // Promise.then callback\n    // setImmediate callback\n    // setTimeout callback\n    // (Note: setTimeout and setImmediate order can sometimes vary slightly based on system load,\n    // but nextTick and Promise microtasks are consistently before them.)"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   Error-handling middleware in Express.js is defined with an arity of four arguments: `(err, req, res, next)`. Express recognizes a function with four arguments as an error-handling middleware. It typically receives control when an error is passed to `next(err)` by another middleware or route handler.\n    *   Yes, middleware can be applied globally using `app.use()`, to specific paths using `app.use('/api', myMiddleware)`, or to specific HTTP methods and routes using `app.get('/users', myMiddleware, (req, res) => {...})`.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    const express = require('express');\n    const app = express();\n    const port = 3000;\n\n    // A simple logging middleware\n    const loggerMiddleware = (req, res, next) => {\n        const timestamp = new Date().toISOString();\n        console.log(`${timestamp} - ${req.method} ${req.url}`);\n        next(); // Pass control to the next middleware or route handler\n    };\n\n    // Apply the logging middleware globally\n    app.use(loggerMiddleware);\n\n    // A route handler\n    app.get('/', (req, res) => {\n        res.send('Hello from Express!');\n    });\n\n    // Another route with specific middleware\n    const authMiddleware = (req, res, next) => {\n        if (req.query.admin === 'true') {\n            console.log('Admin access granted');\n            next();\n        } else {\n            res.status(403).send('Access Denied');\n        }\n    };\n\n    app.get('/admin', authMiddleware, (req, res) => {\n        res.send('Welcome, Admin!');\n    });\n\n    app.listen(port, () => {\n        console.log(`Server listening at http://localhost:${port}`);\n    });\n    ```\n\n---"],"codeExamples":["const express = require('express');\n    const app = express();\n    const port = 3000;\n\n    // A simple logging middleware\n    const loggerMiddleware = (req, res, next) => {\n        const timestamp = new Date().toISOString();\n        console.log(`${timestamp} - ${req.method} ${req.url}`);\n        next(); // Pass control to the next middleware or route handler\n    };\n\n    // Apply the logging middleware globally\n    app.use(loggerMiddleware);\n\n    // A route handler\n    app.get('/', (req, res) => {\n        res.send('Hello from Express!');\n    });\n\n    // Another route with specific middleware\n    const authMiddleware = (req, res, next) => {\n        if (req.query.admin === 'true') {\n            console.log('Admin access granted');\n            next();\n        } else {\n            res.status(403).send('Access Denied');\n        }\n    };\n\n    app.get('/admin', authMiddleware, (req, res) => {\n        res.send('Welcome, Admin!');\n    });\n\n    app.listen(port, () => {\n        console.log(`Server listening at http://localhost:${port}`);\n    });"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   You can pass a value into a generator by providing an argument to the `iterator.next()` method. This value will be assigned as the result of the `yield` expression that paused the generator.\n    *   Generators are inherently iterable. When a generator function is called, it returns an iterator, and this iterator conforms to the iterable protocol (it has a `[Symbol.iterator]()` method that returns `this`). This means generators can be directly used with `for...of` loops, which will iterate over the values yielded by the generator until it finishes.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    function* idGenerator() {\n        let id = 1;\n        while (true) {\n            const reset = yield id++;\n            if (reset) {\n                id = 1;\n            }\n        }\n    }\n\n    const gen = idGenerator();\n\n    console.log(gen.next().value); // Output: 1\n    console.log(gen.next().value); // Output: 2\n    console.log(gen.next().value); // Output: 3\n\n    // Passing a value back into the generator\n    console.log(gen.next(true).value); // Output: 1 (reset to 1)\n    console.log(gen.next().value); // Output: 2\n\n    // Another example: Fibonacci sequence\n    function* fibonacciGenerator() {\n        let a = 0, b = 1;\n        while (true) {\n            yield a;\n            [a, b] = [b, a + b];\n        }\n    }\n\n    const fibGen = fibonacciGenerator();\n    console.log(fibGen.next().value); // 0\n    console.log(fibGen.next().value); // 1\n    console.log(fibGen.next().value); // 1\n    console.log(fibGen.next().value); // 2\n    console.log(fibGen.next().value); // 3\n    ```\n\n---"],"codeExamples":["function* idGenerator() {\n        let id = 1;\n        while (true) {\n            const reset = yield id++;\n            if (reset) {\n                id = 1;\n            }\n        }\n    }\n\n    const gen = idGenerator();\n\n    console.log(gen.next().value); // Output: 1\n    console.log(gen.next().value); // Output: 2\n    console.log(gen.next().value); // Output: 3\n\n    // Passing a value back into the generator\n    console.log(gen.next(true).value); // Output: 1 (reset to 1)\n    console.log(gen.next().value); // Output: 2\n\n    // Another example: Fibonacci sequence\n    function* fibonacciGenerator() {\n        let a = 0, b = 1;\n        while (true) {\n            yield a;\n            [a, b] = [b, a + b];\n        }\n    }\n\n    const fibGen = fibonacciGenerator();\n    console.log(fibGen.next().value); // 0\n    console.log(fibGen.next().value); // 1\n    console.log(fibGen.next().value); // 1\n    console.log(fibGen.next().value); // 2\n    console.log(fibGen.next().value); // 3"]},{"mainQuestion":"","answer":"","followUps":[],"followUpAnswers":["*   You can convert a `Buffer` back to a string using its `toString()` method, optionally specifying an encoding (e.g., `buffer.toString('utf8')`).\n    *   `Buffer`s are mutable. This means that once a `Buffer` is created, its contents can be directly modified (byte by byte) without creating a new `Buffer` instance. This mutability allows for efficient in-place manipulation of binary data, but it also means that operations like `slice()` return a *view* into the original buffer's memory, not a copy, so changes to the slice will affect the original buffer.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Create a Buffer from a string using UTF-8 encoding (default)\n    const buf1 = Buffer.from('Hello Node.js!');\n    console.log(buf1); // Output: <Buffer 48 65 6c 6c 6f 20 4e 6f 64 65 2e 6a 73 21> (hex representation)\n    console.log(buf1.toString()); // Output: Hello Node.js!\n\n    // Create a Buffer of a specific size (e.g., 10 bytes)\n    const buf2 = Buffer.alloc(10);\n    console.log(buf2); // Output: <Buffer 00 00 00 00 00 00 00 00 00 00> (initialized with zeros)\n\n    // Write to a buffer\n    buf2.write('Hi', 'utf8');\n    console"],"codeExamples":[]}]},{"day":"Day-17","questions":[]}];
        
        function loadDay(day) {
            const dayData = questionsData.find(d => d.day === day);
            const questionsDiv = document.getElementById('questions');
            questionsDiv.innerHTML = `<h2 class="text-2xl font-semibold mb-4">${day}</h2>`;
            dayData.questions.forEach((q, index) => {
                const questionHtml = `
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-medium mb-2">Question ${index + 1}: ${q.mainQuestion}</h3>
                        <p class="mb-2"><strong>Answer:</strong> ${q.answer}</p>
                        <p class="mb-2"><strong>Follow-up Questions:</strong></p>
                        <ul class="list-disc pl-5 mb-2">${q.followUps.map(fq => `<li>${fq}</li>`).join('')}</ul>
                        <p class="mb-2"><strong>Follow-up Answers:</strong></p>
                        <ul class="list-disc pl-5 mb-2">${q.followUpAnswers.map(fa => `<li>${fa}</li>`).join('')}</ul>
                        ${q.codeExamples.length ? `
                            <p class="mb-2"><strong>Code Example(s):</strong></p>
                            <pre class="bg-gray-800 text-white p-4 rounded">${q.codeExamples.join('\n\n')}</pre>
                        ` : ''}
                    </div>
                `;
                questionsDiv.innerHTML += questionHtml;
            });
        }

        // Load the first day by default
        if (questionsData.length > 0) loadDay(questionsData[0].day);
    </script>
</body>
</html>
    