[
  "Welcome to Day 1 of your interview prep! It's great to have you here. Today, we'll dive into some fundamental concepts in JavaScript and Node.js. Don't worry, we'll start with the basics and gradually ramp up the difficulty. Think of this as a friendly discussion to gauge your understanding.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: Can you explain the key differences between `var`, `let`, and `const` in JavaScript?\n2.  **Answer**:\n    *   **`var`**: Function-scoped and hoisted. Variables declared with `var` are accessible throughout the function they are declared in, regardless of block scope. They are also \"hoisted\" to the top of their function or global scope, meaning you can use them before they are declared (though their value will be `undefined` until the declaration is reached).\n    *   **`let`**: Block-scoped and not hoisted (in the sense that they are in a \"temporal dead zone\"). `let` limits the variable's scope to the block (e.g., inside `if` statements, `for` loops, or curly braces `{}`) where it is declared. You cannot access a `let` variable before its declaration in code.\n    *   **`const`**: Block-scoped and not hoisted, similar to `let`. The main difference is that `const` declares a constant, meaning its value cannot be reassigned after initialization. However, for objects and arrays declared with `const`, their *properties* or *elements* can still be modified.\n3.  **Follow-up Questions**:\n    *   Which keyword would you typically use for loop counters, and why?\n    *   What happens if you try to reassign a `const` variable?\n    *   Can you declare a `const` variable without initializing it?\n4.  **Follow-up Answers**:\n    *   For loop counters, `let` is typically used because it provides block-scoping. This ensures that the loop counter variable is confined to the loop's scope, preventing unintended side effects or conflicts with variables outside the loop.\n    *   If you try to reassign a `const` variable, JavaScript will throw a `TypeError` because `const` values cannot be reassigned.\n    *   No, you cannot declare a `const` variable without initializing it. It must be assigned a value at the time of declaration, otherwise, it will result in a `SyntaxError`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // var example\n    function varScope() {\n        if (true) {\n            var x = 10;\n        }\n        console.log(x); // Output: 10 (var is function-scoped)\n    }\n    varScope();\n\n    // let/const example\n    function letConstScope() {\n        if (true) {\n            let y = 20;\n            const z = 30;\n            // z = 31; // This would throw a TypeError\n            console.log(y, z); // Output: 20 30\n        }\n        // console.log(y); // This would throw a ReferenceError (y is not defined)\n        // console.log(z); // This would throw a ReferenceError (z is not defined)\n    }\n    letConstScope();\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: What are the primitive data types in JavaScript?\n2.  **Answer**: Primitive data types are basic, immutable values. In JavaScript, there are seven primitive data types:\n    *   `string`: Represents text (e.g., `'hello'`, `\"world\"`).\n    *   `number`: Represents both integers and floating-point numbers (e.g., `10`, `3.14`).\n    *   `boolean`: Represents a logical entity (`true` or `false`).\n    *   `undefined`: Represents a variable that has been declared but not yet assigned a value.\n    *   `null`: Represents the intentional absence of any object value. It's a primitive value.\n    *   `symbol`: (ES6) Represents a unique identifier. Used for unique object property keys.\n    *   `bigint`: (ES2020) Represents integers with arbitrary precision (larger than `2^53 - 1`).\n3.  **Follow-up Questions**:\n    *   Is `null` an object? Explain `typeof null`.\n    *   What is the difference between `undefined` and `null`?\n    *   Can you give an example where `symbol` would be useful?\n4.  **Follow-up Answers**:\n    *   No, `null` is not an object. The `typeof null` returning `'object'` is a long-standing bug in JavaScript that has been maintained for backward compatibility. Conceptually, `null` is a primitive value representing the intentional absence of a value.\n    *   `undefined` means a variable has been declared but not assigned a value, or a function argument that was not provided. `null` is an assignment value, meaning it can be assigned to a variable as a representation of \"no value\" or \"empty.\"\n    *   `Symbol` is useful for creating unique property keys in objects to avoid naming collisions, especially when extending objects with properties that might conflict with existing or future properties. For example, a third-party library might add a property to an object using a `Symbol` to ensure it doesn't overwrite any existing string-named properties.\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log(typeof \"hello\");    // string\n    console.log(typeof 123);        // number\n    console.log(typeof true);       // boolean\n    console.log(typeof undefined);  // undefined\n    console.log(typeof null);       // object (historical bug)\n    console.log(typeof Symbol('id')); // symbol\n    console.log(typeof 10n);        // bigint\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: Explain the difference between `==` (loose equality) and `===` (strict equality) in JavaScript.\n2.  **Answer**:\n    *   **`==` (Loose Equality)**: Compares two values for equality *after* performing type coercion. This means if the two values are of different types, JavaScript will try to convert one or both values to a common type before making the comparison. This can lead to unexpected results.\n    *   **`===` (Strict Equality)**: Compares two values for equality *without* performing any type coercion. It returns `true` only if both the value *and* the type are the same. This is generally recommended for predictable comparisons.\n3.  **Follow-up Questions**:\n    *   When might `==` be useful, if ever?\n    *   What is the result of `null == undefined` and `null === undefined`? Why?\n    *   How does `NaN` behave with both `==` and `===`?\n4.  **Follow-up Answers**:\n    *   While generally discouraged due to its unpredictable nature, `==` can sometimes be used for quick checks where type coercion is explicitly desired, such as checking if a variable is `null` or `undefined` (`value == null` will return true for both `null` and `undefined`). However, for most cases, strict equality is safer.\n    *   `null == undefined` is `true` because `==` performs type coercion, and they are considered loosely equal. `null === undefined` is `false` because their types are different (`null` is `null`, `undefined` is `undefined`).\n    *   `NaN` (Not-a-Number) is unique because it is not equal to itself using either `==` or `===`. `NaN == NaN` is `false`, and `NaN === NaN` is also `false`. To check if a value is `NaN`, you should use `isNaN()` or `Number.isNaN()`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log(5 == '5');   // true (type coercion: string '5' becomes number 5)\n    console.log(5 === '5');  // false (different types: number vs string)\n\n    console.log(null == undefined); // true\n    console.log(null === undefined); // false\n\n    console.log(0 == false); // true\n    console.log(0 === false); // false\n\n    console.log(NaN == NaN); // false\n    console.log(NaN === NaN); // false\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: How do you declare a function in JavaScript? Provide at least two common ways.\n2.  **Answer**: There are several common ways to declare functions in JavaScript:\n    *   **Function Declaration**: The traditional way, where you use the `function` keyword followed by the function name, parameters, and body. These are hoisted.\n    *   **Function Expression**: Assigning an anonymous or named function to a variable. These are not hoisted in the same way; the variable declaration is hoisted, but the function assignment itself is not.\n    *   **Arrow Function (ES6)**: A more concise syntax for writing function expressions. They have lexical `this` binding and are often used for shorter, non-method functions.\n3.  **Follow-up Questions**:\n    *   What is function hoisting? How does it apply to function declarations vs. function expressions?\n    *   When would you choose an arrow function over a regular function expression?\n    *   Can you have a named function expression? What's the benefit?\n4.  **Follow-up Answers**:\n    *   **Function Hoisting**: Function declarations are hoisted to the top of their scope, meaning you can call them before they are declared in the code. Function expressions (and arrow functions) are not hoisted in the same way; their variable declaration is hoisted, but the function definition itself is not, so you cannot call them before the line where they are assigned.\n    *   Arrow functions are generally preferred for shorter, single-expression functions, or when you need to preserve the `this` context from the surrounding lexical scope (e.g., inside callback functions for array methods or event handlers).\n    *   Yes, you can have a named function expression (e.g., `const myFunc = function myFuncName() {}`). The benefit is that the `myFuncName` name is available within the function's own scope for recursion or for clearer debugging stack traces.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // 1. Function Declaration\n    function greet(name) {\n        return `Hello, ${name}!`;\n    }\n    console.log(greet('Alice')); // Output: Hello, Alice!\n\n    // 2. Function Expression\n    const sayHi = function(name) {\n        return `Hi, ${name}!`;\n    };\n    console.log(sayHi('Bob')); // Output: Hi, Bob!\n\n    // 3. Arrow Function\n    const farewell = (name) => `Goodbye, ${name}!`;\n    console.log(farewell('Charlie')); // Output: Goodbye, Charlie!\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: What is \"scope\" in JavaScript, and what are the main types of scope?\n2.  **Answer**: Scope defines the accessibility of variables, functions, and objects in some particular part of your code. It determines where in your program a variable or function can be used or referenced. The main types of scope are:\n    *   **Global Scope**: Variables declared outside of any function or block. They are accessible from anywhere in the JavaScript code.\n    *   **Function (Local) Scope**: Variables declared inside a function. They are only accessible within that function.\n    *   **Block Scope (ES6 `let`/`const`)**: Variables declared with `let` or `const` inside a block (e.g., `if` statements, `for` loops, or any pair of `{}`) are only accessible within that block.\n3.  **Follow-up Questions**:\n    *   Why is it generally considered bad practice to use too many global variables?\n    *   Can a variable declared in an inner function access variables from its outer function?\n    *   What is lexical scope?\n4.  **Follow-up Answers**:\n    *   Too many global variables can lead to naming collisions, making code harder to maintain and debug, especially in large applications or when integrating with third-party libraries. They also increase the risk of unintended side effects.\n    *   Yes, a variable declared in an inner function can access variables from its outer (enclosing) function's scope. This is a fundamental concept related to closures.\n    *   Lexical scope (or static scope) means that the scope of a variable is determined at the time of writing the code (lexical analysis), not at runtime. This means that a function's access to variables from its outer scope is fixed by where it is defined in the code, not by where it is called.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global Scope\n    const globalVar = \"I'm global\";\n\n    function outerFunction() {\n        // Function Scope (outerFunction's scope)\n        const outerVar = \"I'm in outerFunction\";\n\n        if (true) {\n            // Block Scope\n            let blockVar = \"I'm in a block\";\n            console.log(globalVar);  // Accessible\n            console.log(outerVar);   // Accessible\n            console.log(blockVar);   // Accessible\n        }\n        // console.log(blockVar); // ReferenceError: blockVar is not defined\n\n        function innerFunction() {\n            // Function Scope (innerFunction's scope)\n            const innerVar = \"I'm in innerFunction\";\n            console.log(globalVar);  // Accessible\n            console.log(outerVar);   // Accessible (due to lexical scope)\n            console.log(innerVar);   // Accessible\n        }\n        innerFunction();\n    }\n    outerFunction();\n    // console.log(outerVar); // ReferenceError: outerVar is not defined\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: What is \"hoisting\" in JavaScript? Provide an example for variables and functions.\n2.  **Answer**: Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, *before* code execution.\n    *   **Variable Hoisting (`var`)**: Only the declaration is hoisted, not the initialization. Variables declared with `var` are initialized with `undefined` when hoisted.\n    *   **Function Hoisting**: Entire function declarations are hoisted, meaning you can call a function declared this way before its actual definition in the code. Function expressions and arrow functions are not hoisted in the same manner.\n3.  **Follow-up Questions**:\n    *   Does `let` or `const` hoisting behave differently from `var`?\n    *   What is the \"Temporal Dead Zone\" (TDZ) in relation to hoisting?\n    *   Why is understanding hoisting important for writing predictable code?\n4.  **Follow-up Answers**:\n    *   `let` and `const` declarations are also hoisted, but they are not initialized with `undefined`. Instead, they remain in a \"Temporal Dead Zone\" (TDZ) until their declaration is actually executed. Accessing them before their declaration results in a `ReferenceError`.\n    *   The \"Temporal Dead Zone\" (TDZ) is the period between the start of a block and the declaration of `let` or `const` variables within that block. During this time, the variables cannot be accessed, even though they are technically hoisted.\n    *   Understanding hoisting is crucial to avoid unexpected `undefined` values or `ReferenceError`s. It helps write more predictable and maintainable code by encouraging declarations at the top of their scope or using `let`/`const` which enforce declaration before use.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Variable Hoisting with var\n    console.log(myVar); // Output: undefined (declaration is hoisted)\n    var myVar = 10;\n    console.log(myVar); // Output: 10\n\n    // Function Hoisting\n    sayHello(); // Output: Hello! (entire function is hoisted)\n    function sayHello() {\n        console.log(\"Hello!\");\n    }\n\n    // Example with let/const (TDZ)\n    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization\n    let myLet = 20;\n    console.log(myLet); // Output: 20\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: How do you add, remove, and modify elements in a JavaScript array? Provide common methods.\n2.  **Answer**:\n    *   **Adding Elements**:\n        *   `push()`: Adds one or more elements to the *end* of an array and returns the new length.\n        *   `unshift()`: Adds one or more elements to the *beginning* of an array and returns the new length.\n    *   **Removing Elements**:\n        *   `pop()`: Removes the *last* element from an array and returns that element.\n        *   `shift()`: Removes the *first* element from an array and returns that element.\n        *   `splice()`: A versatile method that can add, remove, or replace elements at any position.\n    *   **Modifying Elements**:\n        *   Direct Assignment: Access an element by its index and assign a new value (e.g., `arr[index] = newValue`).\n        *   `splice()`: Can also be used to replace elements by specifying 0 for elements to delete and providing new elements.\n3.  **Follow-up Questions**:\n    *   Which of these methods modify the original array in place?\n    *   How would you add an element at a specific index without removing existing elements using `splice()`?\n    *   What is the difference between `splice()` and `slice()`?\n4.  **Follow-up Answers**:\n    *   `push()`, `unshift()`, `pop()`, `shift()`, and `splice()` all modify the original array in place.\n    *   To add an element at a specific index without removing existing elements using `splice()`, you'd set the `deleteCount` argument to `0`. For example, `arr.splice(index, 0, newElement)`.\n    *   `splice()` modifies the original array by adding/removing/replacing elements and returns the removed elements. `slice()` creates a *new* array containing a shallow copy of a portion of the original array, without modifying the original.\n5.  **Code Example(s)**:\n\n    ```javascript\n    let fruits = ['apple', 'banana', 'cherry'];\n\n    // Add\n    fruits.push('date');      // ['apple', 'banana', 'cherry', 'date']\n    fruits.unshift('apricot'); // ['apricot', 'apple', 'banana', 'cherry', 'date']\n    console.log(\"After adding:\", fruits);\n\n    // Modify\n    fruits[2] = 'blueberry'; // ['apricot', 'apple', 'blueberry', 'cherry', 'date']\n    console.log(\"After modifying:\", fruits);\n\n    // Remove\n    let lastFruit = fruits.pop();    // 'date', fruits is now ['apricot', 'apple', 'blueberry', 'cherry']\n    let firstFruit = fruits.shift(); // 'apricot', fruits is now ['apple', 'blueberry', 'cherry']\n    console.log(\"After removing:\", fruits);\n\n    // Using splice\n    fruits.splice(1, 1, 'grape', 'kiwi'); // At index 1, remove 1 element ('blueberry'), add 'grape', 'kiwi'\n    // fruits is now ['apple', 'grape', 'kiwi', 'cherry']\n    console.log(\"After splice:\", fruits);\n    ```\n\n---\n\n### **Question 8: Intermediate**\n\n1.  **Main Question**: Explain the concept of `this` in JavaScript. How does its value typically change depending on how a function is called?\n2.  **Answer**: `this` is a special keyword in JavaScript that refers to the context in which a function is executed. Its value is determined dynamically at runtime, based on how the function is called.\n    *   **Global Context**: In the global scope (outside any function), `this` refers to the global object (`window` in browsers, `global` in Node.js).\n    *   **Method Call**: When a function is called as a method of an object (e.g., `obj.method()`), `this` refers to the object that owns the method (`obj`).\n    *   **Simple Function Call**: When a function is called as a standalone function (not as a method, e.g., `func()`), `this` refers to the global object in non-strict mode, and `undefined` in strict mode.\n    *   **Constructor Call**: When a function is used as a constructor with the `new` keyword (e.g., `new MyObject()`), `this` refers to the newly created instance of the object.\n    *   **Explicit Binding (`call`, `apply`, `bind`)**: You can explicitly set the value of `this` using these methods.\n    *   **Arrow Functions**: Arrow functions do not have their own `this` binding. They lexically inherit `this` from their enclosing scope.\n3.  **Follow-up Questions**:\n    *   How does `this` behave inside an arrow function compared to a regular function?\n    *   What is strict mode, and how does it affect `this`?\n    *   Can you predict the value of `this` in a nested function call?\n4.  **Follow-up Answers**:\n    *   Inside an arrow function, `this` is determined by the surrounding lexical (enclosing) scope and cannot be changed by `call`, `apply`, or `bind`. In contrast, a regular function's `this` is dynamically bound based on how it's called.\n    *   Strict mode (`'use strict';`) is a way to opt into a restricted variant of JavaScript. In strict mode, if a function is called as a standalone function (not a method), `this` will be `undefined` instead of the global object. It also prevents accidental global variable creation and throws errors for certain unsafe actions.\n    *   In a nested regular function call, if the inner function is called as a simple function (not a method of an object), its `this` will default to the global object (or `undefined` in strict mode), *not* the `this` of the outer function. This is a common source of confusion, which arrow functions help to solve.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global context\n    console.log(this === global); // In Node.js: true\n\n    // Method call\n    const myObject = {\n        name: 'John',\n        greet: function() {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n    myObject.greet(); // Output: Hello, my name is John (this is myObject)\n\n    // Simple function call (in Node.js, non-strict mode)\n    const greetFunc = myObject.greet;\n    // greetFunc(); // Output: Hello, my name is undefined (this is global/undefined)\n\n    // Arrow function (lexical this)\n    const anotherObject = {\n        name: 'Jane',\n        greetArrow: () => {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n    anotherObject.greetArrow(); // Output: Hello, my name is undefined (this is global/undefined, as arrow func inherits from global scope here)\n\n    // Corrected arrow function usage for 'this'\n    const yetAnotherObject = {\n        name: 'Peter',\n        sayLater: function() {\n            setTimeout(() => {\n                console.log(`Hello, my name is ${this.name}`); // 'this' here refers to 'yetAnotherObject'\n            }, 100);\n        }\n    };\n    yetAnotherObject.sayLater(); // Output: Hello, my name is Peter (after 100ms)\n    ```\n\n---\n\n### **Question 9: Intermediate**\n\n1.  **Main Question**: What are arrow functions (`=>`) in ES6, and what are their primary advantages and disadvantages compared to traditional function expressions?\n2.  **Answer**: Arrow functions provide a more concise syntax for writing function expressions.\n    *   **Advantages**:\n        *   **Concise Syntax**: Shorter to write, especially for single-expression functions.\n        *   **Lexical `this` Binding**: They do not have their own `this` context. Instead, `this` is inherited from the enclosing (lexical) scope. This solves common `this` binding issues in callbacks and nested functions.\n        *   **No `arguments` object**: They do not have their own `arguments` object, but you can use rest parameters (`...args`) instead.\n        *   **Cannot be used as constructors**: They cannot be called with `new`.\n    *   **Disadvantages**:\n        *   **No `this` binding**: This can be a disadvantage when you *need* a dynamic `this` (e.g., in object methods that need to refer to the object itself, or event handlers that need to refer to the element).\n        *   **No `arguments` object**: If you need access to the `arguments` object, you'd have to use a regular function or convert `arguments` to a rest parameter.\n        *   **Cannot be used as constructors**: You cannot use `new` with arrow functions.\n        *   **Lack of `prototype` property**: They don't have a `prototype` property, so they can't be used to create methods on a prototype chain.\n3.  **Follow-up Questions**:\n    *   When would an arrow function be a poor choice for an object method?\n    *   Can you use `yield` inside an arrow function?\n    *   How would you pass multiple arguments to an arrow function if it doesn't have an `arguments` object?\n4.  **Follow-up Answers**:\n    *   An arrow function would be a poor choice for an object method if that method needs to access the object's properties using `this`. Because arrow functions lexically bind `this`, `this` would refer to the surrounding scope (often the global object or `undefined` in strict mode), not the object itself.\n    *   No, you cannot use the `yield` keyword inside an arrow function. This means arrow functions cannot be used as generator functions.\n    *   You would use rest parameters (`...args`) to collect multiple arguments into an array. For example: `const sum = (...numbers) => numbers.reduce((acc, num) => acc + num, 0);`\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Concise syntax\n    const add = (a, b) => a + b;\n    console.log(add(2, 3)); // Output: 5\n\n    // Lexical this binding\n    function Counter() {\n        this.count = 0;\n        // Regular function would have 'this' point to setTimeout's caller (global/undefined)\n        // Arrow function preserves 'this' from Counter's scope\n        setTimeout(() => {\n            this.count++;\n            console.log(this.count); // Correctly increments Counter's count\n        }, 1000);\n    }\n    const myCounter = new Counter(); // Output: 1 (after 1 second)\n\n    // Bad example for object method\n    const user = {\n        name: 'Alice',\n        greet: () => {\n            console.log(`Hello, ${this.name}`); // 'this' refers to global object\n        }\n    };\n    user.greet(); // Output: Hello, undefined (in Node.js) or Hello, [window.name] (in browser)\n    ```\n\n---\n\n### **Question 10: Intermediate**\n\n1.  **Main Question**: What are callback functions in JavaScript? Provide a simple example of their use.\n2.  **Answer**: A callback function is a function passed as an argument to another function, which is then executed inside the outer function at a later point in time. Callbacks are a fundamental concept for asynchronous programming in JavaScript, but they are also used in synchronous contexts (e.g., array methods like `map`, `filter`).\n3.  **Follow-up Questions**:\n    *   What is \"callback hell\" or the \"pyramid of doom,\" and how can it be avoided?\n    *   Can a callback function be synchronous? Provide an example.\n    *   How do event listeners commonly use callbacks?\n4.  **Follow-up Answers**:\n    *   \"Callback hell\" is a situation in asynchronous JavaScript where multiple nested callbacks make the code difficult to read, understand, and maintain. It's often characterized by deeply indented code. It can be avoided using Promises, `async/await`, or named functions for better modularity.\n    *   Yes, a callback function can be synchronous. For example, array methods like `forEach`, `map`, or `filter` take synchronous callback functions that are executed immediately for each element.\n    *   Event listeners (e.g., for click events, data received) are a classic example of asynchronous callbacks. When an event occurs, the registered callback function is executed. The main program flow doesn't wait for the event; it continues execution, and the callback is invoked when the event happens.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Synchronous callback example (Array.forEach)\n    const numbers = [1, 2, 3];\n    numbers.forEach(function(number) {\n        console.log(number * 2); // Output: 2, 4, 6\n    });\n\n    // Asynchronous callback example (setTimeout)\n    function fetchData(callback) {\n        console.log(\"Fetching data...\");\n        setTimeout(function() {\n            const data = \"Some data from server\";\n            console.log(\"Data fetched!\");\n            ",
  "Welcome to Day 2 of your interview prep! It's great to have you here. Today, we'll continue our deep dive into JavaScript and Node.js, building upon the foundational concepts we discussed yesterday. We'll explore some more advanced JavaScript features and start touching on Node.js specifics.\n\nDon't worry, we'll maintain a friendly and supportive atmosphere. Think of this as another opportunity to showcase your understanding and learn along the way.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: What are Template Literals (also known as Template Strings) in ES6, and what are their primary advantages over traditional string concatenation?\n2.  **Answer**: Template Literals are a new way to define strings in JavaScript, introduced in ES6 (ECMAScript 2015). They are enclosed by backticks (`` ` ``) instead of single or double quotes.\n    *   **Interpolation**: They allow for easy embedding of expressions (variables, function calls, arithmetic) directly within the string using the `${expression}` syntax.\n    *   **Multi-line Strings**: They can span multiple lines without needing special characters like `\\n`.\n    *   **Tagged Templates**: A more advanced feature allowing a function to parse the template literal, giving fine-grained control over how the string is constructed.\n3.  **Follow-up Questions**:\n    *   Can you embed any JavaScript expression inside `${}` within a template literal?\n    *   What happens if you try to use single or double quotes for a template literal?\n    *   What is a \"tagged template\" and how might it be used?\n4.  **Follow-up Answers**:\n    *   Yes, you can embed any valid JavaScript expression, including variables, function calls, arithmetic operations, and even conditional (ternary) operators.\n    *   If you use single or double quotes, it will be treated as a regular string literal, and the special features of template literals (like interpolation or multi-line support) will not work. For example, `${}` would be treated as literal characters.\n    *   A tagged template is a function called with a template literal. The function receives the string parts as its first argument (an array of strings), and then the values of the interpolated expressions as subsequent arguments. This can be used for things like automatic escaping of HTML, internationalization, or specialized string parsing.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Interpolation\n    const name = \"Alice\";\n    const age = 30;\n    const greeting = `Hello, ${name}! You are ${age} years old.`;\n    console.log(greeting); // Output: Hello, Alice! You are 30 years old.\n\n    // Multi-line string\n    const multiLine = `This is the first line.\n    This is the second line.\n        This is indented.`;\n    console.log(multiLine);\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain Destructuring Assignment in JavaScript. Provide examples for both array and object destructuring.\n2.  **Answer**: Destructuring assignment is an ES6 feature that allows you to unpack values from arrays or properties from objects into distinct variables. It provides a more concise and readable way to extract data.\n    *   **Array Destructuring**: Extracts values from an array by matching variables to elements based on their position.\n    *   **Object Destructuring**: Extracts properties from an object by matching variables to property names.\n3.  **Follow-up Questions**:\n    *   Can you assign default values during destructuring? Provide an example.\n    *   How would you skip elements when destructuring an array?\n    *   What is the benefit of using destructuring in function parameters?\n4.  **Follow-up Answers**:\n    *   Yes, you can assign default values. If the extracted value is `undefined`, the default value will be used. Example: `const { name, age = 25 } = person;`\n    *   To skip elements when destructuring an array, you can simply leave a comma placeholder. Example: `const [first, , third] = [1, 2, 3];` (skips the second element).\n    *   Using destructuring in function parameters makes the function signature clearer about what properties or elements it expects from an object or array, and it allows for direct access to those values without needing to use dot notation repeatedly inside the function body. It also enables setting default values for parameters concisely.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Array Destructuring\n    const colors = ['red', 'green', 'blue'];\n    const [firstColor, secondColor] = colors;\n    console.log(firstColor);  // Output: red\n    console.log(secondColor); // Output: green\n\n    // Object Destructuring\n    const user = {\n        id: 1,\n        username: 'coder123',\n        email: 'coder@example.com'\n    };\n    const { username, email } = user;\n    console.log(username); // Output: coder123\n    console.log(email);    // Output: coder@example.com\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: What is the Spread Operator (`...`) in JavaScript, and what are its common use cases?\n2.  **Answer**: The Spread Operator (`...`) is an ES6 feature that allows an iterable (like an array or a string) to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) or key-value pairs (for object literals) are expected. It essentially \"spreads\" the elements of an iterable.\n    *   **Copying Arrays/Objects**: Creates a shallow copy.\n    *   **Concatenating/Merging Arrays/Objects**: Combines multiple arrays or objects.\n    *   **Passing arguments to functions**: Expands an array into individual arguments.\n3.  **Follow-up Questions**:\n    *   How does the spread operator differ from array `slice()` for copying arrays?\n    *   What kind of copy (shallow vs. deep) does the spread operator perform for objects and arrays?\n    *   Can the spread operator be used for strings? If so, what's the result?\n4.  **Follow-up Answers**:\n    *   Both `spread` and `slice()` create shallow copies of arrays. The spread operator is generally more concise and versatile as it can also be used for objects and in function arguments.\n    *   The spread operator performs a **shallow copy**. This means that if the array or object contains nested objects or arrays, those nested structures are still referenced by memory, not copied. Changes to nested structures in the copy will affect the original.\n    *   Yes, the spread operator can be used for strings. It will spread the string into individual characters. For example, `[...'hello']` would result in `['h', 'e', 'l', 'l', 'o']`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Copying and Merging Arrays\n    const arr1 = [1, 2, 3];\n    const arr2 = [...arr1, 4, 5]; // Copy arr1 and add more elements\n    console.log(arr2); // Output: [1, 2, 3, 4, 5]\n\n    // Merging Objects\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { c: 3, d: 4 };\n    const mergedObj = { ...obj1, ...obj2 };\n    console.log(mergedObj); // Output: { a: 1, b: 2, c: 3, d: 4 }\n\n    // Passing arguments to a function\n    function sum(a, b, c) {\n        return a + b + c;\n    }\n    const numbers = [1, 2, 3];\n    console.log(sum(...numbers)); // Output: 6\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: What are Rest Parameters (`...`) in JavaScript, and how do they differ from the Spread Operator?\n2.  **Answer**: Rest Parameters (`...`) are an ES6 feature that allows a function to accept an indefinite number of arguments as an array. They collect all remaining arguments into a single array.\n    The key difference from the Spread Operator is their context of use:\n    *   **Rest Parameters**: Used in **function definitions** to collect multiple arguments into an array.\n    *   **Spread Operator**: Used in **function calls**, array literals, or object literals to expand an iterable into individual elements/arguments/properties.\n3.  **Follow-up Questions**:\n    *   Can a function have multiple rest parameters? Why or why not?\n    *   Where must the rest parameter be placed in a function's parameter list?\n    *   How do rest parameters provide a more modern alternative to the `arguments` object?\n4.  **Follow-up Answers**:\n    *   No, a function can only have one rest parameter. It must be the last parameter in the list because it collects \"all remaining\" arguments. If there were multiple, it would be ambiguous which arguments each rest parameter should collect.\n    *   The rest parameter must always be the last parameter in a function's parameter list.\n    *   Rest parameters provide a modern and often preferred alternative to the deprecated `arguments` object because they give you a real array (not an array-like object), allowing you to use array methods directly on it. They also only capture the arguments that aren't explicitly defined as named parameters, making function signatures clearer.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Rest Parameters in a function definition\n    function sumAll(firstNum, ...remainingNums) {\n        let total = firstNum;\n        for (const num of remainingNums) {\n            total += num;\n        }\n        return total;\n    }\n\n    console.log(sumAll(1, 2, 3, 4)); // Output: 10 (1 is firstNum, [2,3,4] is remainingNums)\n    console.log(sumAll(5));         // Output: 5 (5 is firstNum, [] is remainingNums)\n\n    // Example showing difference between Rest and Spread\n    const numbers = [10, 20, 30];\n\n    // Spread: expands array into individual arguments\n    console.log(Math.max(...numbers)); // Output: 30\n\n    // Rest: collects individual arguments into an array\n    function logArgs(...args) {\n        console.log(args);\n    }\n    logArgs(1, 'hello', true); // Output: [1, 'hello', true]\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: How do you handle errors in JavaScript using `try...catch` blocks? Provide a simple example.\n2.  **Answer**: The `try...catch` statement is used for error handling in JavaScript. It allows you to test a block of code for errors and handle them gracefully without crashing the program.\n    *   The `try` block contains the code that might throw an error.\n    *   If an error occurs within the `try` block, execution jumps to the `catch` block.\n    *   The `catch` block receives the error object as an argument, allowing you to inspect and respond to the error.\n    *   An optional `finally` block can be added, which will execute regardless of whether an error occurred or not (e.g., for cleanup).\n3.  **Follow-up Questions**:\n    *   What type of errors can `try...catch` handle? Are there any it cannot?\n    *   When would you use a `finally` block?\n    *   How would you intentionally throw a custom error in JavaScript?\n4.  **Follow-up Answers**:\n    *   `try...catch` can handle runtime errors (exceptions) that occur synchronously within the `try` block. It cannot directly catch syntax errors (which prevent the script from running at all) or asynchronous errors (like those inside a `setTimeout` or a Promise's rejected state, unless specifically handled with `.catch()` for Promises or nested `try...catch` for async functions).\n    *   A `finally` block is used when you have code that *must* be executed, regardless of whether an error occurred or not. Common use cases include closing file handles, releasing network connections, or cleaning up resources.\n    *   You can intentionally throw a custom error using the `throw` statement, followed by an error object (e.g., `throw new Error('Something went wrong!');` or `throw 'My custom string error';`).\n5.  **Code Example(s)**:\n\n    ```javascript\n    function divide(a, b) {\n        try {\n            if (b === 0) {\n                throw new Error(\"Division by zero is not allowed.\");\n            }\n            return a / b;\n        } catch (error) {\n            console.error(\"An error occurred:\", error.message);\n            return null; // Indicate failure\n        } finally {\n            console.log(\"Division attempt finished.\");\n        }\n    }\n\n    console.log(divide(10, 2)); // Output: 5, then \"Division attempt finished.\"\n    console.log(divide(10, 0)); // Output: \"An error occurred: Division by zero is not allowed.\", then \"Division attempt finished.\", then null\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: What are the fundamental differences between JavaScript running in a web browser and JavaScript running in Node.js?\n2.  **Answer**: While both environments execute JavaScript, they differ significantly in their runtime environments and available APIs:\n    *   **Runtime Environment**:\n        *   **Browser JS**: Runs in the browser's JavaScript engine (e.g., V8 in Chrome, SpiderMonkey in Firefox). It interacts with the DOM, browser events, and browser-specific APIs (e.g., `window`, `document`, `localStorage`).\n        *   **Node.js**: Runs in the Node.js runtime, which also uses the V8 engine, but outside the browser. It interacts with the operating system, file system, network, and Node.js-specific APIs (e.g., `fs`, `http`, `path`, `process`).\n    *   **Global Objects**:\n        *   **Browser JS**: Global object is `window`.\n        *   **Node.js**: Global object is `global`.\n    *   **Modules**:\n        *   **Browser JS**: Traditionally used `<script>` tags, now supports ES Modules (`import`/`export`).\n        *   **Node.js**: Primarily uses CommonJS modules (`require`/`module.exports`), with increasing support for ES Modules.\n    *   **Purpose**:\n        *   **Browser JS**: Primarily for client-side interactivity, UI manipulation, and consuming web APIs.\n        *   **Node.js**: Primarily for server-side development, command-line tools, backend APIs, and handling I/O operations.\n3.  **Follow-up Questions**:\n    *   Can you use `document.getElementById()` in Node.js? Why or why not?\n    *   What is the role of the V8 engine in both environments?\n    *   How does Node.js handle I/O operations differently from a typical browser-based JavaScript application?\n4.  **Follow-up Answers**:\n    *   No, you cannot use `document.getElementById()` in Node.js because `document` is part of the Browser Object Model (BOM) and Document Object Model (DOM), which are specific to web browsers and do not exist in the Node.js runtime.\n    *   The V8 engine is Google's open-source JavaScript engine that compiles JavaScript into machine code. Its role in both environments is to parse and execute JavaScript code efficiently. Node.js leverages V8's speed and non-blocking I/O model for server-side operations, while browsers use it for client-side script execution.\n    *   Node.js handles I/O operations (like file system access or network requests) using a non-blocking, event-driven architecture, primarily through an event loop and libuv (a C++ library). This allows Node.js to perform I/O operations concurrently without blocking the main thread. Browser-based JS also uses an event loop for asynchronous operations, but its I/O is typically limited to network requests (Fetch API, XMLHttpRequest) and user interaction, not direct file system access.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Browser-specific code (will error in Node.js)\n    // console.log(window);\n    // document.body.style.backgroundColor = 'blue';\n\n    // Node.js-specific code (will error in browser without a bundler)\n    // const fs = require('fs');\n    // fs.readFile('./myfile.txt', 'utf8', (err, data) => {\n    //     if (err) throw err;\n    //     console.log(data);\n    // });\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: What is NPM (Node Package Manager), and what is the purpose of the `package.json` file in a Node.js project?\n2.  **Answer**:\n    *   **NPM (Node Package Manager)**: It's the default package manager for Node.js. It serves two main purposes:\n        1.  **Software Registry**: A vast online repository of open-source Node.js packages (libraries, frameworks, tools).\n        2.  **Command-Line Utility**: A tool that helps developers install, manage, and publish Node.js packages.\n    *   **`package.json`**: This file is a manifest for a Node.js project. It's a JSON file that lives in the root directory of your project and contains metadata about the project and its dependencies.\n        *   It defines project properties like `name`, `version`, `description`, `author`, `license`.\n        *   It lists project dependencies (`dependencies` for production, `devDependencies` for development).\n        *   It defines scripts that can be run using `npm run <script-name>`.\n        *   It specifies the main entry point of the application (`main`).\n3.  **Follow-up Questions**:\n    *   What is the difference between `dependencies` and `devDependencies` in `package.json`?\n    *   How would you install a package and save it as a development dependency?\n    *   What happens when you run `npm install` in a project that already has a `package.json` file?\n4.  **Follow-up Answers**:\n    *   `dependencies` are packages required for the application to run in a production environment (e.g., Express.js, React). `devDependencies` are packages only needed during development or testing (e.g., testing frameworks like Jest, build tools like Webpack, linters like ESLint).\n    *   You would use the command `npm install <package-name> --save-dev` or `npm install <package-name> -D`.\n    *   When you run `npm install` without any arguments in a directory containing a `package.json` file, NPM reads the file and installs all the `dependencies` and `devDependencies` listed in it into the `node_modules` folder, ensuring all project requirements are met.\n5.  **Code Example(s)**:\n\n    ```json\n    // Example package.json snippet\n    {\n      \"name\": \"my-node-app\",\n      \"version\": \"1.0.0\",\n      \"description\": \"A simple Node.js application.\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\"\n      },\n      \"dependencies\": {\n        \"express\": \"^4.18.2\",\n        \"lodash\": \"^4.17.21\"\n      },\n      \"devDependencies\": {\n        \"jest\": \"^29.7.0\",\n        \"nodemon\": \"^3.0.1\"\n      },\n      \"author\": \"Your Name\",\n      \"license\": \"MIT\"\n    }\n    ```\n\n---\n\n### **Question 8: Intermediate**\n\n1.  **Main Question**: Explain the concept of \"closures\" in JavaScript. How do they work, and what are some common use cases?\n2.  **Answer**: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In simpler terms, a closure gives you access to an outer function's scope from an inner function.\n    *   **How it works**: When an inner function is defined within an outer function, the inner function \"remembers\" the environment in which it was created. Even if the outer function has finished executing and its scope would normally be destroyed, the closure keeps that scope alive for the inner function to access.\n    *   **Use Cases**:\n        *   **Data Privacy/Encapsulation**: Creating private variables or methods.\n        *   **Currying/Partial Application**: Creating specialized functions.\n        *   **Maintaining State**: In event handlers or asynchronous operations.\n        *   **Module Pattern**: Creating self-contained modules.\n3.  **Follow-up Questions**:\n    *   Can a closure access variables from its outer scope even after the outer function has returned?\n    *   What is a potential pitfall or common mistake when using closures in loops?\n    *   How are closures related to the concept of lexical scope?\n4.  **Follow-up Answers**:\n    *   Yes, this is the core characteristic of a closure. The inner function retains a reference to the outer function's scope, allowing it to access and manipulate variables from that scope even after the outer function has completed execution.\n    *   A common pitfall is when closures are created inside loops using `var`. Because `var` is function-scoped (or global) and hoisted, all closures created in the loop will share the *same* reference to the loop variable's final value, leading to unexpected results. Using `let` or `const` (which are block-scoped) or creating a new scope for each iteration can solve this.\n    *   Closures are fundamentally built upon lexical scope. Lexical scope means that the scope of a variable is determined by its position in the source code (where it's written), not by where it's called. A closure \"closes over\" its lexical environment, meaning it remembers the variables and arguments that were in scope when it was defined.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Data Privacy / Counter\n    function createCounter() {\n        let count = 0; // 'count' is a private variable due to closure\n        return {\n            increment: function() {\n                count++;\n                return count;\n            },\n            decrement: function() {\n                count--;\n                return count;\n            },\n            getCount: function() {\n                return count;\n            }\n        };\n    }\n\n    const counter = createCounter();\n    console.log(counter.increment()); // Output: 1\n    console.log(counter.increment()); // Output: 2\n    console.log(counter.getCount());  // Output: 2\n\n    // Example 2: Closure in a loop (correct way with let)\n    function createFunctions() {\n        const result = [];\n        for (let i = 0; i < 3; i++) { // Using let ensures each iteration has its own 'i'\n            result.push(function() {\n                console.log(i);\n            });\n        }\n        return result;\n    }\n    const funcs = createFunctions();\n    funcs[0](); // Output: 0\n    funcs[1](); // Output: 1\n    funcs[2](); // Output: 2\n    ```\n\n---\n\n### **Question 9: Intermediate**\n\n1.  **Main Question**: Explain the concept of the \"prototype chain\" in JavaScript. How does JavaScript achieve inheritance using prototypes?\n2.  **Answer**: In JavaScript, objects can inherit properties and methods from other objects through a mechanism called the \"prototype chain.\" Every JavaScript object has an internal `[[Prototype]]` property (accessible via `__proto__` or `Object.getPrototypeOf()`) that points to another object, which is its prototype.\n    *   **How it works**: When you try to access a property or method on an object, JavaScript first checks if the property exists directly on that object. If not, it looks for the property on the object's prototype. If still not found, it continues up the prototype chain until it either finds the property or reaches `null` (the end of the chain).\n    *   **Inheritance**: This chain allows objects to inherit properties and methods from their ancestors, mimicking classical inheritance without explicit classes (though ES6 `class` syntax is syntactic sugar over prototypes).\n3.  **Follow-up Questions**:\n    *   What is the `Object.prototype` and where does it sit in the prototype chain?\n    *   How does `instanceof` operator relate to the prototype chain?\n    *   Can you modify an object's prototype after it's been created? What are the implications?\n4.  **Follow-up Answers**:\n    *   `Object.prototype` is the base prototype for all objects in JavaScript. It sits at the very end of most prototype chains (just before `null`). It contains common methods like `toString()`, `hasOwnProperty()`, `isPrototypeOf()`, etc.\n    *   The `instanceof` operator checks if an object's prototype chain contains the `prototype` property of a constructor. For example, `myObject instanceof MyConstructor` returns `true` if `MyConstructor.prototype` exists anywhere in `myObject`'s prototype chain.\n    *   Yes, you can modify an object's prototype using `Object.setPrototypeOf()` or by directly modifying the `__proto__` property (though `__proto__` is generally discouraged for performance reasons and `Object.setPrototypeOf()` is preferred). Modifying a prototype affects all objects that inherit from it, which can have significant and sometimes unintended side effects on existing instances and future instances.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Basic prototype chain\n    const animal = {\n        eats: true,\n        walk() {\n            console.log(\"Animal walks.\");\n        }\n    };\n\n    const rabbit = {\n        jumps: true,\n        __proto__: animal // rabbit inherits from animal\n    };\n\n    const longEar = {\n        earLength: 10,\n        __proto__: rabbit // longEar inherits from rabbit, which inherits from animal\n    };\n\n    console.log(longEar.eats); // Output: true (inherited from animal)\n    longEar.walk();            // Output: Animal walks. (inherited from animal)\n    console.log(longEar.jumps); // Output: true (inherited from rabbit)\n\n    // Example 2: Using Object.create\n    const personPrototype = {\n        greet() {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n\n    const john = Object.create(personPrototype);\n    john.name = \"John\";\n    john.greet(); // Output: Hello, my name is John\n    ```\n\n---\n\n### **Question ",
  "Welcome to Day 3 of your interview prep! It's great to have you here. We've covered a lot of ground in the past two days, focusing on core JavaScript concepts and the fundamental differences between browser and Node.js environments.\n\nToday, we'll continue our deep dive, exploring more advanced JavaScript features, delving deeper into Node.js specifics, and touching upon some architectural and best-practice considerations. Remember, this is a discussion to understand your depth of knowledge.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: What is a JavaScript Promise, and why were Promises introduced? Provide a basic example of how to create and consume a Promise.\n2.  **Answer**: A Promise is an object representing the eventual completion or failure of an asynchronous operation. It acts as a placeholder for a value that is not yet available but will be resolved at some point in the future (or rejected if an error occurs).\n    Promises were introduced in ES6 (ECMAScript 2015) to manage asynchronous operations more cleanly and avoid \"callback hell\" or the \"pyramid of doom,\" which often results from deeply nested callback functions. They provide a more structured and readable way to handle asynchronous code.\n3.  **Follow-up Questions**:\n    *   What are the three states a Promise can be in?\n    *   What is the purpose of `.then()` and `.catch()` methods on a Promise?\n    *   Can a Promise be resolved or rejected more than once?\n4.  **Follow-up Answers**:\n    *   A Promise can be in one of three states:\n        *   **Pending**: Initial state, neither fulfilled nor rejected.\n        *   **Fulfilled (or Resolved)**: Meaning that the operation completed successfully.\n        *   **Rejected**: Meaning that the operation failed.\n    *   `.then()` is used to register a callback function that will be executed when the Promise is successfully fulfilled. It can take two arguments: one for success and one for failure (though `.catch()` is generally preferred for errors). `.catch()` is a shorthand for `.then(null, rejectionHandler)` and is used to register a callback function that will be executed when the Promise is rejected, providing a cleaner way to handle errors.\n    *   No, a Promise can only settle (resolve or reject) once. Once it transitions from `pending` to either `fulfilled` or `rejected`, its state becomes immutable, and any further attempts to resolve or reject it will be ignored.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Creating a Promise\n    const myPromise = new Promise((resolve, reject) => {\n        const success = true; // Simulate an async operation result\n        setTimeout(() => {\n            if (success) {\n                resolve(\"Data fetched successfully!\");\n            } else {\n                reject(\"Failed to fetch data.\");\n            }\n        }, 1000);\n    });\n\n    // Consuming a Promise\n    myPromise\n        .then((message) => {\n            console.log(\"Success:\", message);\n        })\n        .catch((error) => {\n            console.error(\"Error:\", error);\n        });\n\n    console.log(\"Promise initiated...\"); // This will log first\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain the purpose of the `async` and `await` keywords in JavaScript. How do they simplify asynchronous code?\n2.  **Answer**: `async` and `await` are syntactic sugar built on top of Promises, introduced in ES2017 (ES8), designed to make asynchronous code look and behave more like synchronous code, making it easier to read and write.\n    *   The `async` keyword is used to declare an asynchronous function. An `async` function implicitly returns a Promise. If the function returns a non-Promise value, it's wrapped in a resolved Promise.\n    *   The `await` keyword can only be used inside an `async` function. It pauses the execution of the `async` function until the Promise it's waiting for settles (either resolves or rejects). If the Promise resolves, `await` returns its resolved value. If it rejects, `await` throws the rejected value as an error, which can then be caught using `try...catch`.\n3.  **Follow-up Questions**:\n    *   What happens if you use `await` outside an `async` function?\n    *   How do you handle errors when using `async/await`?\n    *   Can `async/await` completely replace Promises, or are they complementary?\n4.  **Follow-up Answers**:\n    *   Using `await` outside an `async` function will result in a `SyntaxError`. `await` can only be used within `async` functions (or at the top level of JavaScript modules, as of ES2022).\n    *   Errors with `async/await` are handled using standard `try...catch` blocks. If an `await`ed Promise rejects, it throws an error that can be caught by a surrounding `try...catch` block.\n    *   `async/await` doesn't replace Promises; rather, it builds on top of them. `async` functions always return Promises, and `await` expressions always wait for Promises. They are complementary, with `async/await` providing a more ergonomic syntax for consuming Promises.\n5.  **Code Example(s)**:\n\n    ```javascript\n    function fetchUser() {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve({ id: 1, name: 'Alice' });\n            }, 1000);\n        });\n    }\n\n    async function getUserData() {\n        console.log(\"Fetching user...\");\n        try {\n            const user = await fetchUser(); // Pause execution until fetchUser Promise resolves\n            console.log(\"User data:\", user);\n            return user;\n        } catch (error) {\n            console.error(\"Error fetching user:\", error);\n            throw error; // Re-throw to propagate the error\n        }\n    }\n\n    getUserData();\n    console.log(\"Operation started...\"); // This logs before user data\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: What are ES Modules (`import`/`export`) in JavaScript, and why are they preferred over older module patterns like CommonJS (`require`/`module.exports`) for front-end development?\n2.  **Answer**: ES Modules (ECMAScript Modules), introduced in ES6, provide a standardized way to organize JavaScript code into reusable units. They use `import` to bring in functionality from other modules and `export` to make functionality available.\n    While Node.js traditionally used CommonJS, ES Modules are preferred for front-end development because:\n    *   **Standardization**: They are an official part of the JavaScript language specification, supported natively by modern browsers.\n    *   **Static Analysis**: Imports and exports are resolved at compile time (or parse time), allowing for better static analysis, tree-shaking (removing unused code), and optimized bundling.\n    *   **Asynchronous Loading**: ES Modules are designed to be loaded asynchronously, which is crucial for performance in web browsers.\n    *   **Clearer Syntax**: The `import`/`export` syntax is generally considered more declarative and readable.\n3.  **Follow-up Questions**:\n    *   What is the difference between named exports and default exports?\n    *   Can ES Modules be used in Node.js? If so, how?\n    *   What is \"tree-shaking\" and how does it relate to ES Modules?\n4.  **Follow-up Answers**:\n    *   **Named Exports**: Allow you to export multiple values from a module by their names (e.g., `export const foo = ...; export function bar() { ... }`). When importing, you must use the exact names (e.g., `import { foo, bar } from './myModule';`).\n    *   **Default Exports**: Allows you to export a single \"main\" value from a module (e.g., `export default myValue;`). When importing, you can give it any name you want (e.g., `import MyValue from './myModule';`). A module can have only one default export.\n    *   Yes, ES Modules can be used in Node.js. You can enable them by setting `\"type\": \"module\"` in your `package.json` file, or by using the `.mjs` file extension for your module files.\n    *   \"Tree-shaking\" (or dead code elimination) is a build optimization process that removes unused code from your final JavaScript bundle. It works effectively with ES Modules because their static nature allows bundlers (like Webpack or Rollup) to determine exactly which exports are being used and which are not, thus excluding the unused code.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // myModule.js\n    export const PI = 3.14; // Named export\n    export function sum(a, b) { // Named export\n        return a + b;\n    }\n    const subtract = (a, b) => a - b;\n    export default subtract; // Default export\n\n    // main.js\n    import { PI, sum } from './myModule.js';\n    import mySubtractFunction from './myModule.js'; // Can name it anything\n\n    console.log(PI); // Output: 3.14\n    console.log(sum(5, 3)); // Output: 8\n    console.log(mySubtractFunction(10, 4)); // Output: 6\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: What is JSON (JavaScript Object Notation), and why is it so widely used for data exchange in web applications?\n2.  **Answer**: JSON (JavaScript Object Notation) is a lightweight data-interchange format. It's a text-based format that is completely language-independent but uses conventions that are familiar to programmers of the C-family of languages (including JavaScript).\n    It's widely used for data exchange in web applications because:\n    *   **Human-readable**: It's easy for humans to read and write.\n    *   **Machine-parseable**: It's easy for machines to parse and generate.\n    *   **Lightweight**: Its syntax is minimal, making it efficient for data transfer.\n    *   **Language-agnostic**: While derived from JavaScript, it's a universal format that can be used with almost any programming language.\n    *   **Direct mapping to objects/arrays**: Its structure directly maps to JavaScript objects and arrays, making parsing and serialization straightforward in JavaScript environments.\n3.  **Follow-up Questions**:\n    *   What are the basic data types supported in JSON?\n    *   What is the difference between `JSON.parse()` and `JSON.stringify()`?\n    *   Can JSON directly store JavaScript functions or `Date` objects?\n4.  **Follow-up Answers**:\n    *   JSON supports the following basic data types: strings, numbers, booleans (`true`/`false`), `null`, objects (key-value pairs), and arrays.\n    *   `JSON.parse()` takes a JSON string as input and converts it into a JavaScript object or value. `JSON.stringify()` takes a JavaScript object or value as input and converts it into a JSON string.\n    *   No, JSON cannot directly store JavaScript functions or `Date` objects. When `JSON.stringify()` encounters a function, `undefined`, or a Symbol, it will either omit it or convert it to `null`. `Date` objects are converted to ISO 8601 strings when stringified.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // JavaScript Object\n    const user = {\n        name: \"Jane Doe\",\n        age: 28,\n        isAdmin: false,\n        courses: [\"JS\", \"Node\", \"React\"]\n    };\n\n    // Convert JavaScript object to JSON string\n    const jsonString = JSON.stringify(user);\n    console.log(\"JSON String:\", jsonString);\n    // Output: {\"name\":\"Jane Doe\",\"age\":28,\"isAdmin\":false,\"courses\":[\"JS\",\"Node\",\"React\"]}\n\n    // Convert JSON string back to JavaScript object\n    const parsedObject = JSON.parse(jsonString);\n    console.log(\"Parsed Object:\", parsedObject);\n    // Output: { name: 'Jane Doe', age: 28, isAdmin: false, courses: [ 'JS', 'Node', 'React' ] }\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: Explain the fundamental difference between synchronous and asynchronous operations in JavaScript. Why is asynchronous programming crucial for web and Node.js applications?\n2.  **Answer**:\n    *   **Synchronous Operations**: Execute sequentially, one after another. Each operation must complete before the next one starts. If a synchronous operation takes a long time, it will \"block\" the execution of the rest of the code, making the application unresponsive.\n    *   **Asynchronous Operations**: Execute independently and in parallel with the main program flow. They initiate a task (like fetching data from a server or reading a file) and then immediately return control to the main program. When the task completes, a callback function (or Promise resolution) is executed.\n    Asynchronous programming is crucial because:\n    *   **Non-blocking UI (Web)**: In browsers, long-running synchronous tasks would freeze the user interface, leading to a poor user experience. Asynchronous operations ensure the UI remains responsive.\n    *   **Scalability (Node.js)**: Node.js is single-threaded. If I/O operations (like network requests or database queries) were synchronous, the server would be blocked waiting for each operation to complete, severely limiting its ability to handle multiple concurrent requests. Asynchronous I/O allows Node.js to handle many requests efficiently without blocking the main thread.\n3.  **Follow-up Questions**:\n    *   Can you give an example of a built-in JavaScript function that is synchronous and one that is asynchronous?\n    *   What mechanism does JavaScript use to handle asynchronous operations?\n    *   If you have two asynchronous operations, how can you ensure one runs only after the other completes?\n4.  **Follow-up Answers**:\n    *   **Synchronous**: `alert()`, `prompt()`, `console.log()`, array methods like `map()`, `filter()`, `JSON.parse()`.\n    *   **Asynchronous**: `setTimeout()`, `setInterval()`, `fetch()`, `XMLHttpRequest`, Node.js `fs.readFile()`.\n    *   JavaScript uses the **Event Loop** (along with the Call Stack, Web APIs/Node.js C++ APIs, and Callback Queue/Microtask Queue) to manage asynchronous operations.\n    *   You can ensure sequential execution of asynchronous operations using:\n        *   **Callbacks**: Nesting them (though this can lead to callback hell).\n        *   **Promises**: Chaining `.then()` calls.\n        *   **`async/await`**: Using `await` to pause execution until a Promise resolves.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Synchronous example\n    console.log(\"Start sync operation.\");\n    for (let i = 0; i < 1000000000; i++) {\n        // Simulate a heavy synchronous task\n    }\n    console.log(\"End sync operation.\"); // This logs after the loop finishes\n\n    // Asynchronous example\n    console.log(\"Start async operation.\");\n    setTimeout(() => {\n        console.log(\"Async operation completed after 1 second.\");\n    }, 1000);\n    console.log(\"End async operation (this logs before the timeout).\");\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: How do you create and manipulate objects in JavaScript? List at least three common ways to create objects.\n2.  **Answer**: JavaScript objects are collections of key-value pairs (properties) and functions (methods).\n    Common ways to create objects:\n    1.  **Object Literal Syntax**: The simplest and most common way.\n        ```javascript\n        const myObject = {\n            key1: 'value1',\n            method1: function() { /* ... */ }\n        };\n        ```\n    2.  **`new Object()` Constructor**: Less common than literal, but equivalent.\n        ```javascript\n        const myObject = new Object();\n        myObject.key1 = 'value1';\n        myObject.method1 = function() { /* ... */ };\n        ```\n    3.  **Constructor Functions**: Used to create multiple objects of the same \"type\" with shared properties and methods.\n        ```javascript\n        function Person(name, age) {\n            this.name = name;\n            this.age = age;\n            this.greet = function() {\n                console.log(`Hello, my name is ${this.name}`);\n            };\n        }\n        const john = new Person('John', 30);\n        ```\n    4.  **ES6 Classes**: Syntactic sugar over constructor functions and prototypes.\n        ```javascript\n        class Car {\n            constructor(make, model) {\n                this.make = make;\n                this.model = model;\n            }\n            start() {\n                console.log(`${this.make} ${this.model} started.`);\n            }\n        }\n        const myCar = new Car('Toyota', 'Camry');\n        ```\n    5.  **`Object.create()`**: Creates a new object, using an existing object as the prototype of the newly created object.\n        ```javascript\n        const proto = { value: 10 };\n        const obj = Object.create(proto);\n        console.log(obj.value); // 10\n        ```\n    **Manipulation**:\n    *   **Add/Modify Property**: `obj.newProp = 'value';` or `obj['anotherProp'] = 'value';`\n    *   **Access Property**: `obj.propName` or `obj['propName']`\n    *   **Delete Property**: `delete obj.propName;`\n3.  **Follow-up Questions**:\n    *   What is the main advantage of using constructor functions or ES6 classes over object literals for creating multiple similar objects?\n    *   How does property access using dot notation (`obj.prop`) differ from bracket notation (`obj['prop']`)?\n    *   When would you use `Object.create()`?\n4.  **Follow-up Answers**:\n    *   The main advantage is reusability and consistency. They allow you to define a blueprint for objects, ensuring all instances have the same structure and methods, and facilitate inheritance through the prototype chain. Object literals are good for single, unique objects.\n    *   Dot notation is used when the property name is a fixed, valid JavaScript identifier. Bracket notation is used when the property name is dynamic (e.g., stored in a variable) or contains special characters (like spaces or hyphens) that are not valid in dot notation.\n    *   `Object.create()` is useful when you want to create an object with a specific prototype object, allowing for explicit control over the prototype chain. It's often used for classical inheritance patterns or when you want to create a truly empty object without `Object.prototype` in its chain (`Object.create(null)`).\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Object Literal\n    const book = {\n        title: \"The Great Gatsby\",\n        author: \"F. Scott Fitzgerald\",\n        year: 1925,\n        getSummary: function() {\n            return `${this.title} by ${this.author} (${this.year})`;\n        }\n    };\n    console.log(book.getSummary());\n\n    // ES6 Class\n    class Vehicle {\n        constructor(type) {\n            this.type = type;\n        }\n        drive() {\n            console.log(`Driving the ${this.type}.`);\n        }\n    }\n    const myBike = new Vehicle('bicycle');\n    myBike.drive();\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: What is type coercion in JavaScript? Provide examples of both implicit and explicit type coercion.\n2.  **Answer**: Type coercion is the automatic or implicit conversion of values from one data type to another (e.g., number to string, string to boolean). JavaScript is a loosely typed language, and it often performs type coercion when operations involve values of different types.\n    *   **Implicit Coercion**: JavaScript automatically converts types without explicit instruction from the developer. This often happens with equality operators (`==`), logical operators, and arithmetic operations.\n    *   **Explicit Coercion**: The developer intentionally converts types using built-in functions or methods (e.g., `Number()`, `String()`, `Boolean()`, `parseInt()`).\n3.  **Follow-up Questions**:\n    *   Why is implicit coercion sometimes considered a \"gotcha\" in JavaScript?\n    *   What is the result of `[] + {}` and `{}` + `[]` in JavaScript, and why?\n    *   How can you explicitly convert a string to a number, and vice-versa?\n4.  **Follow-up Answers**:\n    *   Implicit coercion can lead to unexpected and hard-to-debug behavior because JavaScript's rules for coercion can be complex and non-obvious. For example, `0 == false` is true, `'1' == 1` is true, but `[] == ![]` is also true. This unpredictability is why strict equality (`===`) is generally preferred.\n    *   `[] + {}` results in the string `\"[object Object]\"`. When `+` operator is used with an array and an object, both are converted to primitive values. `[]` becomes `\"\"` and `{}` becomes `\"[object Object]\"`, then concatenated.\n    *   `{}` + `[]` is more complex. In a browser's console, if `{}` is at the start of a line, it's often parsed as a block statement, not an object literal, so it's ignored. The expression then becomes `+[]`, which coerces `[]` to `0`. If wrapped in parentheses `({} + [])`, it would result in `\"[object Object]\"`. In Node.js, `{}` is always parsed as an object literal, so it results in `\"[object Object]\"`. This highlights the \"gotcha\" nature.\n    *   **String to Number**: `Number('123')`, `parseInt('123')`, `parseFloat('3.14')`, or using the unary plus operator `+'123'`.\n    *   **Number to String**: `String(123)`, `(123).toString()`, or using string concatenation `'' + 123`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Implicit Coercion\n    console.log(5 + '5');      // \"55\" (number 5 coerced to string \"5\", then concatenated)\n    console.log(true + 1);     // 2 (boolean true coerced to number 1)\n    console.log('10' / '2');   // 5 (strings \"10\" and \"2\" coerced to numbers, then division)\n    console.log(null == undefined); // true (loosely equal)\n    console.log(0 == false);   // true (loosely equal)\n\n    // Explicit Coercion\n    console.log(Number('123'));    // 123\n    console.log(String(456));      // \"456\"\n    console.log(Boolean(0));       // false\n    console.log(Boolean('hello')); // true\n    ```\n\n---\n\n### **Question 8: Intermediate**\n\n1.  **Main Question**: Explain the `call()`, `apply()`, and `bind()` methods in JavaScript. How do they relate to the `this` keyword?\n2.  **Answer**: `call()`, `apply()`, and `bind()` are methods available on all JavaScript functions (as functions are objects). Their primary purpose is to explicitly control the value of the `this` keyword inside a function, allowing you to set the context of execution.\n    *   **`call()`**: Invokes the function immediately with a specified `this` context and arguments passed individually.\n        `func.call(thisArg, arg1, arg2, ...)`\n    *   **`apply()`**: Invokes the function immediately with a specified `this` context and arguments passed as an array (or array-like object).\n        `func.apply(thisArg, [argsArray])`\n    *   **`bind()`**: Returns a *new function* (a \"bound function\") with the `this` context permanently bound to a specified value, and optionally, initial arguments. The function is *not* invoked immediately.\n        `func.bind(thisArg, arg1, arg2, ...)`\n3.  **Follow-up Questions**:\n    *   When would you typically choose `call()` over `apply()`, and vice versa?\n    *   Why is `bind()` particularly useful in event handling or when passing functions as callbacks?\n    *   Can `call()`, `apply()`, or `bind()` be used with arrow functions to change their `this` context?\n4.  **Follow-up Answers**:\n    *   You'd choose `call()` when you know the arguments beforehand and can pass them individually. You'd choose `apply()` when you have the arguments in an array or an array-like object (e.g., `arguments` object) and want to pass them all at once.\n    *   `bind()` is useful in event handling or callbacks because it allows you to create a new function with a fixed `this` context without immediately executing it. This ensures that when the event fires or the callback is invoked later, `this` will correctly refer to the intended object, rather than the global object or `undefined` (in strict mode).\n    *   No, `call()`, `apply()`, or `bind()` cannot change the `this` context of an arrow function. Arrow functions have lexical `this` binding, meaning their `this` value is determined by their surrounding scope at the time of definition, and it cannot be overridden by these methods.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const person = {\n        name: 'Alice',\n        greet: function(city, country) {\n            console.log(`Hello, my name is ${this.name} from ${city}, ${country}.`);\n        }\n    };\n\n    const anotherPerson = {\n        name: 'Bob'\n    };\n\n    // Using call() - arguments passed individually\n    person.greet.call(anotherPerson, 'New York', 'USA'); // Output: Hello, my name is Bob from New York, USA.\n\n    // Using apply() - arguments passed as an array\n    const args = ['London', 'UK'];\n    person.greet.apply(anotherPerson, args); // Output: Hello, my name is Bob from London, UK.\n\n    // Using bind() - returns a new function\n    const boundGreet = person.greet.bind(anotherPerson, 'Paris', 'France');\n    boundGreet(); // Output: Hello, my name is Bob from Paris, France.\n    ```\n\n---\n\n### **Question 9: Intermediate**\n\n1.  **Main Question**: Explain what the Node.js Event Loop is and how it enables Node.js to handle concurrency with a single-threaded model.\n2.  **Answer**: The Node.js Event Loop is the core mechanism that allows Node.js to perform non-blocking I/O operations despite being single-threaded. It continuously checks for tasks in the Call Stack, and if the Call Stack is empty, it processes events from the Callback Queue.\n    **How it works**:\n    1.  **Call Stack**: Executes synchronous code.\n    2.  **Node.js APIs (libuv)**: When an asynchronous operation (like a file read or network request) is encountered, it's offloaded to Node.js's underlying C++ APIs (powered by libuv, which uses a thread pool for heavy I/O).\n    3.  **Callback Queue (Task Queue)**: Once an asynchronous operation completes, its associated callback function is placed into the Callback Queue.\n    4.  **Event Loop**: The Event Loop's job is to constantly monitor the Call Stack. If the Call Stack is empty, it takes the first callback from the Callback Queue and pushes it onto the Call Stack for execution.\n    This continuous cycle allows Node.js to initiate many I/O operations without waiting for each to complete, keeping the single main thread free to handle other requests, thus achieving high concurrency.\n3.  **Follow-up Questions**:\n    *   Name the different phases of the Node.js Event Loop and briefly describe their purpose.\n    *   What is the difference between `process.nextTick()` and `setImmediate()` in relation to the Event Loop?\n    *   How does the Node.js Event Loop differ from the browser's Event Loop?\n4.  **Follow-up Answers**:\n    *   The Node.js Event Loop has several phases:\n        *   **timers**: Executes `setTimeout()` and `setInterval()` callbacks.\n        *   **pending callbacks**: Executes I/O callbacks deferred to the next loop iteration.\n        *   **idle, prepare**: Internal to Node",
  "Welcome to Day 4 of your interview prep! It's great to have you here. We've covered a lot of fundamental ground in the past three days, from JavaScript basics to asynchronous patterns and Node.js essentials.\n\nToday, we'll continue our deep dive, exploring more advanced JavaScript features, delving deeper into Node.js specifics, and touching upon some architectural and best-practice considerations. Remember, this is a discussion to understand your depth of knowledge.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: What are Higher-Order Functions in JavaScript? Provide an example of how they are commonly used with array methods.\n2.  **Answer**: A Higher-Order Function (HOF) is a function that either takes one or more functions as arguments, or returns a function as its result, or both. They are a fundamental concept in functional programming and enable powerful abstractions and code reuse. Common JavaScript array methods like `map()`, `filter()`, and `reduce()` are excellent examples of built-in higher-order functions.\n3.  **Follow-up Questions**:\n    *   Why are Higher-Order Functions considered a powerful feature in JavaScript?\n    *   Can you name another common scenario (besides array methods) where you might encounter Higher-Order Functions?\n    *   What is a \"callback function\" in the context of a Higher-Order Function?\n4.  **Follow-up Answers**:\n    *   They promote code reusability, modularity, and abstraction. They allow for more declarative programming (describing *what* to do rather than *how* to do it) and make code more concise and easier to reason about.\n    *   Another common scenario is in event handling, where you pass a function to be executed when an event occurs (e.g., `element.addEventListener('click', myFunction)`). Also, middleware functions in frameworks like Express.js are HOFs.\n    *   A callback function is simply the function that is passed as an argument to a Higher-Order Function and is intended to be executed at a later point in time by the HOF.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example: Using map() as a HOF to transform an array\n    const numbers = [1, 2, 3, 4];\n\n    // The anonymous function (num) => num * 2 is the callback\n    const doubledNumbers = numbers.map((num) => num * 2);\n    console.log(doubledNumbers); // Output: [2, 4, 6, 8]\n\n    // Example: A custom HOF\n    function operateOnArray(arr, operation) {\n        const result = [];\n        for (let i = 0; i < arr.length; i++) {\n            result.push(operation(arr[i]));\n        }\n        return result;\n    }\n\n    const addFive = (num) => num + 5;\n    const numbersPlusFive = operateOnArray(numbers, addFive);\n    console.log(numbersPlusFive); // Output: [6, 7, 8, 9]\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain the purpose and typical use cases for the `map()`, `filter()`, and `reduce()` array methods in JavaScript.\n2.  **Answer**: These are three of the most commonly used higher-order array methods in JavaScript, enabling powerful data transformations and manipulations.\n    *   **`map()`**: Creates a *new array* by calling a provided function on every element in the calling array. It's used for **transforming** each element.\n    *   **`filter()`**: Creates a *new array* containing all elements from the calling array that satisfy a provided test function. It's used for **selecting** a subset of elements.\n    *   **`reduce()`**: Executes a reducer function (that you provide) on each element of the array, resulting in a *single output value*. It's used for **accumulating** a single value from the array.\n3.  **Follow-up Questions**:\n    *   Do `map()`, `filter()`, and `reduce()` modify the original array?\n    *   When would `forEach()` be more appropriate than `map()`?\n    *   Can you achieve the functionality of `filter()` or `map()` using `reduce()`?\n4.  **Follow-up Answers**:\n    *   No, all three methods (`map()`, `filter()`, `reduce()`) return a *new array* (or a single value for `reduce()`) and do not modify the original array. This makes them suitable for functional programming paradigms and immutability.\n    *   `forEach()` is appropriate when you need to iterate over an array and perform a side effect for each element (e.g., logging to the console, updating a DOM element) but you don't need to create a new array or return a value from the iteration. `map()` is specifically for transforming elements into a new array.\n    *   Yes, you can achieve the functionality of `filter()` and `map()` using `reduce()`, as `reduce()` is the most versatile of the three. For `map()`, you'd accumulate a new array with transformed elements. For `filter()`, you'd accumulate a new array with only the elements that pass a condition.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const products = [\n        { id: 1, name: 'Laptop', price: 1200 },\n        { id: 2, name: 'Mouse', price: 25 },\n        { id: 3, name: 'Keyboard', price: 75 },\n        { id: 4, name: 'Monitor', price: 300 }\n    ];\n\n    // map(): Get just product names\n    const productNames = products.map(product => product.name);\n    console.log(\"Names:\", productNames); // Output: [\"Laptop\", \"Mouse\", \"Keyboard\", \"Monitor\"]\n\n    // filter(): Get products under $100\n    const affordableProducts = products.filter(product => product.price < 100);\n    console.log(\"Affordable:\", affordableProducts);\n    // Output: [{ id: 2, name: 'Mouse', price: 25 }, { id: 3, name: 'Keyboard', price: 75 }]\n\n    // reduce(): Calculate total price of all products\n    const totalPrice = products.reduce((sum, product) => sum + product.price, 0);\n    console.log(\"Total Price:\", totalPrice); // Output: 1600\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: What are \"truthy\" and \"falsy\" values in JavaScript? List all the common falsy values.\n2.  **Answer**: In JavaScript, every value has an inherent boolean value. When a non-boolean value is evaluated in a boolean context (e.g., in an `if` statement, `&&`, `||`, or `!`), it is coerced into a boolean `true` or `false`.\n    *   **Falsy values**: Values that coerce to `false` when evaluated in a boolean context.\n    *   **Truthy values**: All values that are not falsy.\n    The common falsy values are:\n    1.  `false` (the boolean primitive)\n    2.  `0` (the number zero)\n    3.  `-0` (the negative number zero)\n    4.  `0n` (BigInt zero)\n    5.  `\"\"` (an empty string)\n    6.  `null`\n    7.  `undefined`\n    8.  `NaN` (Not-a-Number)\n3.  **Follow-up Questions**:\n    *   Is an empty array (`[]`) truthy or falsy? What about an empty object (`{}`)?\n    *   How can you explicitly convert a value to its boolean equivalent?\n    *   Give an example of how a falsy value might unexpectedly affect program flow.\n4.  **Follow-up Answers**:\n    *   Both an empty array (`[]`) and an empty object (`{}`) are **truthy** in JavaScript.\n    *   You can explicitly convert a value to its boolean equivalent using the `Boolean()` constructor (e.g., `Boolean(value)`) or by using the double negation operator (`!!value`).\n    *   A common example is checking if a string is empty: `if (username)` would evaluate to `false` if `username` is an empty string, which is often the desired behavior. However, `if (count)` would evaluate to `false` if `count` is `0`, which might not be desired if `0` is a valid count.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Falsy examples\n    if (0) { console.log(\"0 is truthy\"); } else { console.log(\"0 is falsy\"); }\n    // Output: 0 is falsy\n\n    if (\"\") { console.log(\"Empty string is truthy\"); } else { console.log(\"Empty string is falsy\"); }\n    // Output: Empty string is falsy\n\n    // Truthy examples\n    if ([]) { console.log(\"Empty array is truthy\"); } else { console.log(\"Empty array is falsy\"); }\n    // Output: Empty array is truthy\n\n    if ({}) { console.log(\"Empty object is truthy\"); } else { console.log(\"Empty object is falsy\"); }\n    // Output: Empty object is truthy\n\n    const myVar = null;\n    if (myVar) {\n        console.log(\"myVar is truthy\");\n    } else {\n        console.log(\"myVar is falsy\"); // This will execute\n    }\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: Explain the concepts of \"Event Bubbling\" and \"Event Capturing\" in the DOM. How do they relate to event propagation?\n2.  **Answer**: When an event occurs on a DOM element (e.g., a click), that event doesn't just happen on that element. It propagates through the DOM tree in a specific order, known as event propagation. This process has three phases:\n    1.  **Capturing Phase**: The event starts from the `window` object, then travels down to the target element.\n    2.  **Target Phase**: The event reaches the actual element that triggered it.\n    3.  **Bubbling Phase**: The event bubbles up from the target element back to the `window` object.\n    *   **Event Bubbling (default)**: The event handler is triggered first on the target element, and then on its parent, then on its grandparent, and so on, up to the root of the DOM. This is the default behavior of `addEventListener()`.\n    *   **Event Capturing**: The event handler is triggered first on the outermost ancestor element (e.g., `window` or `document`), then on its child, and so on, down to the target element. You enable capturing by passing `true` as the third argument to `addEventListener()`.\n3.  **Follow-up Questions**:\n    *   Which phase is the default behavior for `addEventListener()`?\n    *   How can you stop event propagation at a certain point?\n    *   When might you specifically want to use event capturing instead of bubbling?\n4.  **Follow-up Answers**:\n    *   The default behavior for `addEventListener()` is **Event Bubbling**. If you omit the third argument or set it to `false`, the listener will be triggered during the bubbling phase.\n    *   You can stop event propagation using `event.stopPropagation()` within an event handler. This prevents the event from bubbling up (or capturing down) to parent (or child) elements after the current handler has executed.\n    *   Event capturing is less commonly used than bubbling. It can be useful when you want to intercept events at a higher level in the DOM tree before they reach the target element, for example, to implement a global event listener that needs to process events before specific element listeners, or to prevent certain actions on child elements.\n5.  **Code Example(s)**:\n\n    ```html\n    <!-- HTML Structure -->\n    <div id=\"grandparent\" style=\"padding: 20px; background: lightblue;\">\n        Grandparent\n        <div id=\"parent\" style=\"padding: 20px; background: lightcoral;\">\n            Parent\n            <button id=\"child\">Child Button</button>\n        </div>\n    </div>\n\n    <script>\n        const grandparent = document.getElementById('grandparent');\n        const parent = document.getElementById('parent');\n        const child = document.getElementById('child');\n\n        // Bubbling (default)\n        grandparent.addEventListener('click', () => console.log('Grandparent (Bubbling)'));\n        parent.addEventListener('click', () => console.log('Parent (Bubbling)'));\n        child.addEventListener('click', () => console.log('Child (Bubbling)'));\n\n        // Capturing (third argument is true)\n        grandparent.addEventListener('click', () => console.log('Grandparent (Capturing)'), true);\n        parent.addEventListener('click', () => console.log('Parent (Capturing)'), true);\n        child.addEventListener('click', () => console.log('Child (Capturing)'), true);\n\n        // If you click \"Child Button\":\n        // Output Order:\n        // Grandparent (Capturing)\n        // Parent (Capturing)\n        // Child (Bubbling) / Child (Capturing) - depending on order of addEventListener for child\n        // Parent (Bubbling)\n        // Grandparent (Bubbling)\n    </script>\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: What is \"Event Delegation\" in JavaScript, and what are its primary benefits?\n2.  **Answer**: Event delegation is a technique where you attach a single event listener to a parent element, rather than attaching separate listeners to each of its child elements. When an event occurs on a child element, it bubbles up to the parent, and the single listener on the parent then handles the event. The listener uses event object properties (like `event.target`) to identify which specific child element triggered the event.\n    Primary benefits:\n    *   **Performance**: Reduces the number of event listeners attached to the DOM, especially beneficial for large lists or tables. Fewer listeners mean less memory consumption and faster page rendering.\n    *   **Dynamic Elements**: Automatically handles events for elements that are added to the DOM dynamically *after* the initial page load, without needing to attach new listeners to them.\n    *   **Simpler Code**: Can lead to cleaner and more maintainable code by centralizing event handling logic.\n3.  **Follow-up Questions**:\n    *   What property of the `Event` object is crucial for implementing event delegation?\n    *   When might event delegation not be the best approach?\n    *   Can event delegation be used with any type of event?\n4.  **Follow-up Answers**:\n    *   The `event.target` property is crucial. It refers to the actual DOM element that originally dispatched the event (the element that was clicked, typed in, etc.), allowing the delegated listener on the parent to identify the source of the event.\n    *   Event delegation might not be the best approach if the event does not bubble (e.g., `focus`, `blur` by default), or if the event handler logic becomes overly complex due to many different types of child elements requiring distinct handling. Also, if there are very few child elements, the overhead of delegation might not be justified.\n    *   No, not all events bubble. Events like `focus`, `blur`, `load`, `unload`, `scroll`, and `resize` do not bubble. Therefore, event delegation cannot be used for these types of events unless they are explicitly set to bubble (which is rare for these events).\n5.  **Code Example(s)**:\n\n    ```html\n    <!-- HTML Structure -->\n    <ul id=\"myList\">\n        <li>Item 1</li>\n        <li>Item 2</li>\n        <li>Item 3</li>\n        <li class=\"special\">Item 4 (Special)</li>\n    </ul>\n    <button id=\"addItem\">Add New Item</button>\n\n    <script>\n        const myList = document.getElementById('myList');\n        const addItemButton = document.getElementById('addItem');\n\n        // Use event delegation on the parent <ul>\n        myList.addEventListener('click', function(event) {\n            // Check if the clicked element is an <li>\n            if (event.target.tagName === 'LI') {\n                console.log('Clicked on list item:', event.target.textContent);\n\n                // Specific action for special items\n                if (event.target.classList.contains('special')) {\n                    event.target.style.backgroundColor = 'yellow';\n                } else {\n                    event.target.style.backgroundColor = 'lightgreen';\n                }\n            }\n        });\n\n        // Add new items dynamically\n        addItemButton.addEventListener('click', () => {\n            const newItem = document.createElement('li');\n            newItem.textContent = `New Item ${myList.children.length + 1}`;\n            myList.appendChild(newItem);\n            console.log('Added new item. Event delegation still works!');\n        });\n    </script>\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: How do you read from and write to files in Node.js using the built-in `fs` (File System) module? Provide examples for both synchronous and asynchronous operations.\n2.  **Answer**: The `fs` module provides an API for interacting with the file system. It offers both synchronous and asynchronous methods for most operations. Asynchronous methods are generally preferred in Node.js to avoid blocking the Event Loop.\n    *   **Reading Files**:\n        *   `fs.readFile(path, [options], callback)`: Asynchronously reads the entire contents of a file.\n        *   `fs.readFileSync(path, [options])`: Synchronously reads the entire contents of a file.\n    *   **Writing Files**:\n        *   `fs.writeFile(file, data, [options], callback)`: Asynchronously writes data to a file, replacing the file if it already exists.\n        *   `fs.writeFileSync(file, data, [options])`: Synchronously writes data to a file.\n3.  **Follow-up Questions**:\n    *   Why are asynchronous `fs` methods generally preferred over synchronous ones in Node.js?\n    *   What happens if an error occurs during a file operation using an asynchronous method?\n    *   How would you append data to an existing file instead of overwriting it?\n4.  **Follow-up Answers**:\n    *   Asynchronous `fs` methods are preferred because Node.js is single-threaded. Synchronous I/O operations block the main thread, preventing it from handling other requests or tasks until the file operation completes. Asynchronous methods offload the I/O operation to the underlying system, allowing the Node.js process to continue handling other work, leading to better performance and scalability, especially for server-side applications.\n    *   If an error occurs during an asynchronous file operation, the error object will be passed as the first argument to the callback function. It's crucial to check for this `err` object in your callback and handle it appropriately (e.g., logging the error, sending an error response).\n    *   To append data to an existing file, you would use `fs.appendFile()` (asynchronous) or `fs.appendFileSync()` (synchronous). These methods add the data to the end of the file without overwriting its existing content.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const fs = require('fs');\n    const path = require('path');\n\n    const filePath = path.join(__dirname, 'sample.txt');\n    const newContent = 'Hello from Node.js!\\n';\n\n    // --- Asynchronous File Operations ---\n\n    // Write to file (async)\n    fs.writeFile(filePath, newContent, (err) => {\n        if (err) {\n            console.error('Async Write Error:', err);\n            return;\n        }\n        console.log('File written asynchronously.');\n\n        // Read from file (async)\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                console.error('Async Read Error:', err);\n                return;\n            }\n            console.log('Async Read Content:', data);\n        });\n    });\n\n    // --- Synchronous File Operations ---\n\n    try {\n        const syncContent = 'This is synchronous content.\\n';\n        fs.writeFileSync(filePath, syncContent);\n        console.log('File written synchronously.');\n\n        const data = fs.readFileSync(filePath, 'utf8');\n        console.log('Sync Read Content:', data);\n    } catch (err) {\n        console.error('Synchronous Operation Error:', err);\n    }\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: In Node.js CommonJS modules, what is the fundamental difference between `exports` and `module.exports`? What is the common pitfall associated with this difference?\n2.  **Answer**: In Node.js's CommonJS module system:\n    *   **`module.exports`**: This is the actual object that is returned when a module is `require()`d. By default, it's an empty object `{}`. You can assign any value to `module.exports` (an object, function, string, etc.) and that will be the export of your module.\n    *   **`exports`**: This is a convenience variable that is initially a *reference* to `module.exports`. It's essentially a shortcut, meaning `exports = module.exports`. You can add properties to `exports` (e.g., `exports.myFunc = ...;`), and these properties will be added to the `module.exports` object.\n    **Common Pitfall**: The pitfall arises when developers mistakenly reassign `exports` instead of `module.exports` when they intend to export a single value (like a function or a class).\n    If you do `exports = someValue;`, you are breaking the reference between `exports` and `module.exports`. `module.exports` will still be the original empty object (or whatever it was previously assigned), and `someValue` will not be exported. Only properties added to `exports` directly (e.g., `exports.foo = bar;`) will work as expected, as they modify the object that `module.exports` is still referencing.\n3.  **Follow-up Questions**:\n    *   If you have both `exports.foo = 'bar';` and `module.exports = { baz: 'qux' };` in the same module, what will be exported?\n    *   When is it safe or common to use `exports.propertyName = value;`?\n    *   Can you use `exports` directly to export a default function, like `exports = function() {}`?\n4.  **Follow-up Answers**:\n    *   If you have both, `module.exports = { baz: 'qux' };` will take precedence. Whatever is assigned to `module.exports` at the end of the module's execution is what gets exported. The `exports.foo = 'bar';` line would have modified the *original* `module.exports` object, but then `module.exports` was reassigned to a *new* object, effectively discarding the changes made via `exports`.\n    *   It's safe and common to use `exports.propertyName = value;` when you want to export *multiple named properties or functions* from your module. For example, `exports.add = (a, b) => a + b; exports.subtract = (a, b) => a - b;`.\n    *   No, you cannot use `exports = function() {}` to export a default function. This will break the reference to `module.exports`, and the module will still export the original `module.exports` object (which might be an empty object or something else). To export a default function, you must use `module.exports = function() {};`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // --- myModule.js ---\n\n    // Correct way to export multiple things\n    exports.add = (a, b) => a + b;\n    exports.subtract = (a, b) => a - b;\n\n    // Correct way to export a single default thing (",
  "Welcome to Day 5 of your interview prep! It's great to have you here. We've covered a lot of ground in the past four days, building a solid foundation in both JavaScript and Node.js.\n\nToday, we'll continue our deep dive, exploring more advanced JavaScript features, delving deeper into Node.js specifics, and touching upon some architectural and best-practice considerations. Remember, this is a discussion to understand your depth of knowledge.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: What are `Set` and `Map` objects in JavaScript, and when would you choose to use one over a plain object or array?\n2.  **Answer**:\n    *   **`Set`**: A `Set` is a collection of unique values. Each value can only occur once in a `Set`. It's useful when you need to store a list of items and ensure no duplicates, or quickly check for the presence of an item.\n    *   **`Map`**: A `Map` is a collection of key-value pairs where the keys can be of any data type (unlike plain objects, where keys are typically strings or Symbols). It maintains the insertion order of its elements. It's useful when you need to store data as key-value pairs and the keys are not necessarily strings, or when you need to iterate over the keys in insertion order.\n    **When to choose them**:\n    *   **`Set` over Array**: If you need to store unique items and quickly check for existence or remove duplicates from an existing array.\n    *   **`Map` over Object**: If you need to use non-string keys (e.g., objects, functions), if the order of key-value pairs matters, or if you frequently add/remove key-value pairs and need better performance for large collections. Plain objects are better for simple structured data where keys are known strings.\n3.  **Follow-up Questions**:\n    *   How do you add elements to a `Set` and a `Map`?\n    *   Can you iterate over `Set` and `Map` objects? If so, how?\n    *   What is the difference between `Map` and `WeakMap`?\n4.  **Follow-up Answers**:\n    *   For `Set`, use `mySet.add(value)`. For `Map`, use `myMap.set(key, value)`.\n    *   Yes, both `Set` and `Map` are iterable. You can use a `for...of` loop directly on them: `for (const item of mySet) { ... }` or `for (const [key, value] of myMap) { ... }`. They also have `forEach` methods and methods like `keys()`, `values()`, and `entries()`.\n    *   `WeakMap` and `WeakSet` are similar to `Map` and `Set` but hold \"weak\" references to their keys (for `WeakMap`) or values (for `WeakSet`). This means if there are no other references to the key/value object, it can be garbage collected, preventing memory leaks. `WeakMap` keys must be objects (not primitives). They are not iterable and do not have a `size` property. They are primarily used for associating data with objects without preventing those objects from being garbage collected.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Set Example\n    const uniqueNumbers = new Set();\n    uniqueNumbers.add(1);\n    uniqueNumbers.add(2);\n    uniqueNumbers.add(1); // Ignored, as 1 is already present\n    console.log(uniqueNumbers); // Set { 1, 2 }\n    console.log(uniqueNumbers.has(2)); // true\n\n    const numbersArray = [1, 2, 2, 3, 4, 4, 5];\n    const uniqueFromArray = [...new Set(numbersArray)]; // Remove duplicates\n    console.log(uniqueFromArray); // [1, 2, 3, 4, 5]\n\n    // Map Example\n    const userRoles = new Map();\n    userRoles.set('alice', 'admin');\n    userRoles.set('bob', 'editor');\n    const userObj = { id: 123 };\n    userRoles.set(userObj, 'guest'); // Key can be an object\n\n    console.log(userRoles.get('alice')); // admin\n    console.log(userRoles.get(userObj)); // guest\n    console.log(userRoles.size); // 3\n\n    for (const [key, value] of userRoles) {\n        console.log(`${key}: ${value}`);\n    }\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain the `Symbol` primitive data type in JavaScript. What is its primary purpose and how is it used?\n2.  **Answer**: `Symbol` is a primitive data type introduced in ES6 (ES2015). A `Symbol` value represents a unique and immutable identifier.\n    *   **Primary Purpose**: Its main purpose is to create unique object property keys that won't clash with other properties, even those with the same string name. This is particularly useful when extending objects with private-like properties or when third-party libraries add properties to objects without risking name collisions.\n    *   **Usage**: You create a Symbol by calling `Symbol()` with an optional description string (for debugging purposes).\n3.  **Follow-up Questions**:\n    *   Can two Symbols created with the same description be strictly equal (`===`)?\n    *   How do you access a property of an object whose key is a Symbol?\n    *   Can Symbols be iterated over using `for...in` or `Object.keys()`?\n4.  **Follow-up Answers**:\n    *   No. Each time `Symbol()` is called, it returns a new, unique Symbol value, even if the description string is identical. So, `Symbol('foo') === Symbol('foo')` will always be `false`.\n    *   You access Symbol-keyed properties using bracket notation, not dot notation. For example, `myObject[mySymbolKey]`.\n    *   No. Symbols are non-enumerable by default, meaning they are ignored by `for...in` loops, `Object.keys()`, `Object.values()`, and `Object.entries()`. You can retrieve Symbol properties using `Object.getOwnPropertySymbols(obj)`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const id1 = Symbol('id');\n    const id2 = Symbol('id');\n\n    console.log(id1 === id2); // false (always unique)\n\n    const user = {\n        name: 'John',\n        [id1]: 123, // Use Symbol as a key\n        [id2]: 456\n    };\n\n    console.log(user.name);    // John\n    console.log(user[id1]);    // 123\n    console.log(user[id2]);    // 456\n\n    // Symbols are not enumerated by standard loops\n    for (let key in user) {\n        console.log(key); // Only 'name' will be logged\n    }\n\n    // To get Symbol properties\n    console.log(Object.getOwnPropertySymbols(user)); // [ Symbol(id), Symbol(id) ]\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: What is the `global` object in Node.js, and how does it compare to the `window` object in a web browser environment?\n2.  **Answer**:\n    *   The `global` object in Node.js is the global namespace for Node.js environments. It's similar in concept to the `window` object in browsers, providing access to globally available variables, functions, and objects. Any variable declared without `var`, `let`, or `const` (in non-strict mode) becomes a property of `global`.\n    *   **Comparison to `window`**:\n        *   **Environment**: `global` is specific to Node.js (server-side/runtime), while `window` is specific to web browsers (client-side).\n        *   **APIs**: `window` provides browser-specific APIs (DOM manipulation, `localStorage`, `XMLHttpRequest`, `alert`, `document`, `navigator`). `global` provides Node.js-specific APIs (`process`, `Buffer`, `setTimeout`, `console`, `__dirname`, `__filename`).\n        *   **Scope**: In Node.js, each module has its own separate scope, so variables declared with `var`, `let`, or `const` at the top level of a module are *not* added to the `global` object, unlike in browser scripts where global variables are added to `window`.\n3.  **Follow-up Questions**:\n    *   Can you directly access `global` properties without explicitly writing `global.`?\n    *   Name a few important properties or methods available on the `global` object in Node.js.\n    *   Why is it generally discouraged to pollute the `global` object?\n4.  **Follow-up Answers**:\n    *   Yes, similar to `window` in browsers, properties of the `global` object can be accessed directly without the `global.` prefix (e.g., `console.log` is actually `global.console.log`, `setTimeout` is `global.setTimeout`).\n    *   Important properties/methods include: `process`, `Buffer`, `console`, `setTimeout`, `setInterval`, `setImmediate`, `clearTimeout`, `clearInterval`, `clearImmediate`, `__dirname`, `__filename`, `require`, `module`, `exports`.\n    *   Polluting the `global` object (creating global variables) is discouraged because it can lead to naming collisions, make code harder to debug and maintain, and reduce modularity, especially in larger applications or when integrating third-party libraries. It breaks encapsulation and can lead to unexpected side effects.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // In Node.js environment:\n\n    // Accessing global properties directly\n    console.log('Hello from global console!');\n    setTimeout(() => {\n        console.log('This is a global setTimeout.');\n    }, 100);\n\n    // Explicitly using global\n    global.myGlobalVar = 'I am a global variable!';\n    console.log(myGlobalVar); // Accessible directly\n\n    // Variables declared with let/const are NOT global in Node modules\n    let moduleVar = 'I am module-scoped';\n    // console.log(global.moduleVar); // undefined\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: Explain the purpose of the `path` module in Node.js. Provide a common use case.\n2.  **Answer**: The Node.js `path` module provides utilities for working with file and directory paths. It offers methods to join, resolve, normalize, and parse paths in a way that is consistent across different operating systems (Windows, Linux, macOS). This is crucial because path separators and conventions differ between OSes (e.g., `\\` on Windows, `/` on Unix-like systems).\n    **Common Use Case**: Constructing file paths reliably, especially when dealing with paths provided by users or other modules, or when the application needs to run on multiple operating systems.\n3.  **Follow-up Questions**:\n    *   What is the difference between `path.join()` and `path.resolve()`?\n    *   How would you get the directory name and file name from a full path string?\n    *   Why is using `path.join()` or `path.resolve()` preferred over simple string concatenation for paths?\n4.  **Follow-up Answers**:\n    *   `path.join()` concatenates path segments into a single path string, normalizing the result (e.g., handling extra slashes). It creates a relative or absolute path based on the input segments.\n    *   `path.resolve()` resolves a sequence of paths or path segments into an absolute path. It processes paths from right to left, prepending the current working directory if the resulting path is not absolute. It's often used to get an absolute path from a relative one.\n    *   You would use `path.dirname(fullPath)` to get the directory name and `path.basename(fullPath)` to get the file name (or `path.parse(fullPath)` for an object with all components).\n    *   Using `path.join()` or `path.resolve()` is preferred because they correctly handle platform-specific path separators (`\\` vs `/`), normalize paths (e.g., remove redundant `.` or `..`), and deal with leading/trailing slashes, preventing errors and ensuring portability across different operating systems.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const path = require('path');\n\n    // path.join()\n    const filePath = path.join('/users', 'john', 'documents', 'report.txt');\n    console.log('Joined path:', filePath); // On Windows: \\users\\john\\documents\\report.txt, On Linux: /users/john/documents/report.txt\n\n    // path.resolve()\n    const absolutePath = path.resolve('src', 'data', 'config.json');\n    console.log('Resolved absolute path:', absolutePath); // e.g., /home/user/my-app/src/data/config.json\n\n    // path.dirname() and path.basename()\n    const fullPath = '/home/user/documents/report.txt';\n    console.log('Directory name:', path.dirname(fullPath)); // /home/user/documents\n    console.log('File name:', path.basename(fullPath));    // report.txt\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: Beyond simple `console.log()`, what are some other useful `console` methods in Node.js (and browsers), and when would you use them?\n2.  **Answer**: The `console` object provides a variety of methods for debugging and logging information to the console.\n    *   **`console.log(data, ...)`**: General output of messages.\n    *   **`console.warn(data, ...)`**: Outputs a warning message. Often styled differently (e.g., yellow background) in browsers.\n    *   **`console.error(data, ...)`**: Outputs an error message. Often styled differently (e.g., red background) and includes stack traces in Node.js.\n    *   **`console.info(data, ...)`**: Outputs an informational message.\n    *   **`console.table(data)`**: Displays tabular data (arrays of objects or arrays) as a table. Extremely useful for inspecting complex data structures.\n    *   **`console.time(label)` / `console.timeEnd(label)`**: Starts a timer with a given label. When `timeEnd()` is called with the same label, it stops the timer and logs the elapsed time. Useful for performance profiling.\n    *   **`console.count(label)`**: Logs the number of times `count()` has been called with the same label. Useful for tracking function calls in loops.\n    *   **`console.trace(message)`**: Prints a stack trace to the console. Useful for understanding how a particular piece of code was reached.\n3.  **Follow-up Questions**:\n    *   How would you measure the execution time of a specific function or block of code using `console` methods?\n    *   When debugging, why might `console.error()` be preferred over `console.log()` for error messages?\n    *   Can you clear the console using a `console` method?\n4.  **Follow-up Answers**:\n    *   You would use `console.time(label)` before the code block you want to measure and `console.timeEnd(label)` after it. The `label` must be the same for both calls.\n    *   `console.error()` is preferred because it typically formats the output as an error (e.g., red text, error icon), making errors more visible. In Node.js, it also prints to `stderr` (standard error stream) instead of `stdout` (standard output stream), which is good practice for separating error logs from regular output, and allows tools to differentiate them. It can also include stack traces automatically.\n    *   Yes, `console.clear()` can be used to clear the console.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Measuring performance\n    console.time('ArrayProcessing');\n    const largeArray = Array.from({ length: 1000000 }, (_, i) => i);\n    const transformedArray = largeArray.map(num => num * 2);\n    console.timeEnd('ArrayProcessing'); // Logs something like: ArrayProcessing: 12.345ms\n\n    // Tabular data\n    const users = [\n        { name: 'Alice', age: 30, city: 'New York' },\n        { name: 'Bob', age: 24, city: 'London' }\n    ];\n    console.table(users);\n\n    // Counting\n    function processItem(item) {\n        console.count('Processed Items');\n        // ... some processing\n    }\n    processItem(1);\n    processItem(2);\n    processItem(3); // Processed Items: 3\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: How do you access command-line arguments passed to a Node.js script? Provide an example.\n2.  **Answer**: In Node.js, command-line arguments are accessible through the `process.argv` global property. `process.argv` is an array that contains the command-line arguments passed when the Node.js process was launched.\n    *   The first element (`process.argv[0]`) is the path to the Node.js executable.\n    *   The second element (`process.argv[1]`) is the path to the JavaScript file being executed.\n    *   Subsequent elements (`process.argv[2]`, `process.argv[3]`, etc.) are the actual arguments provided by the user.\n3.  **Follow-up Questions**:\n    *   If you run `node app.js --env production`, what would be the values at `process.argv[0]`, `process.argv[1]`, and `process.argv[2]`?\n    *   How can you easily extract named arguments (e.g., `--port=3000`) from `process.argv`?\n    *   What is the difference between `process.argv` and `process.env`?\n4.  **Follow-up Answers**:\n    *   `process.argv[0]` would be the path to the Node.js executable (e.g., `/usr/local/bin/node`).\n    *   `process.argv[1]` would be the path to your script (e.g., `/path/to/your/app.js`).\n    *   `process.argv[2]` would be `--env`.\n    *   For extracting named arguments, you typically need to parse `process.argv` manually or, more commonly, use a third-party library like `minimist` or `yargs` which provide more robust argument parsing capabilities.\n    *   `process.argv` contains command-line arguments specifically passed to the script, while `process.env` contains environment variables (e.g., `PORT`, `NODE_ENV`) that are set in the operating system's environment where the Node.js process is running.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Save this as `args_example.js`\n    // Run from terminal: node args_example.js hello world --name Alice --age 30\n\n    console.log('All arguments:', process.argv);\n\n    const userArgs = process.argv.slice(2); // Get only the custom arguments\n    console.log('Custom arguments:', userArgs);\n\n    if (userArgs.length > 0) {\n        console.log(`First argument: ${userArgs[0]}`);\n        console.log(`Second argument: ${userArgs[1]}`);\n    }\n\n    // A simple way to parse named args (for illustration, use libraries in real apps)\n    const options = {};\n    userArgs.forEach(arg => {\n        if (arg.startsWith('--')) {\n            const parts = arg.slice(2).split('=');\n            options[parts[0]] = parts.length > 1 ? parts[1] : true;\n        }\n    });\n    console.log('Parsed options:', options);\n    // Expected output for the example run command:\n    // Parsed options: { name: 'Alice', age: '30' }\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: In Node.js, what is the significance of `__dirname` and `__filename`? When would you use them?\n2.  **Answer**: `__dirname` and `__filename` are global variables available in every Node.js module (but not in ES Modules by default).\n    *   **`__dirname`**: Provides the absolute path to the directory containing the currently executing script file.\n    *   **`__filename`**: Provides the absolute path to the currently executing script file itself (including the filename).\n    **Significance and Use Cases**: They are crucial for creating robust and portable file paths within Node.js applications, especially when dealing with file system operations (like reading/writing files, loading modules, serving static assets) where relative paths might become ambiguous or break when the script is executed from a different working directory.\n3.  **Follow-up Questions**:\n    *   Are `__dirname` and `__filename` available when using ES Modules (`import`/`export`) in Node.js? If not, how do you get equivalent information?\n    *   How would you construct an absolute path to a `data.json` file located in the same directory as your script using `__dirname`?\n    *   Why are these variables more reliable than `process.cwd()` for locating module-specific resources?\n4.  **Follow-up Answers**:\n    *   No, `__dirname` and `__filename` are not directly available in ES Modules. To get equivalent information, you can use `import.meta.url`. You'd then use Node.js's `url` and `path` modules to convert `import.meta.url` (a `file://` URL) into a file path and extract the directory or filename.\n    *   You would use `const path = require('path'); const dataFilePath = path.join(__dirname, 'data.json');`.\n    *   `__dirname` and `__filename` always refer to the location of the *current module file*, regardless of the current working directory from which the Node.js process was started (`process.cwd()`). This makes them much more reliable for resolving paths to resources relative to the module itself. `process.cwd()` can change, leading to broken paths if not handled carefully.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Save this as `info.js`\n    const path = require('path');\n    const fs = require('fs');\n\n    console.log('__dirname:', __dirname);\n    console.log('__filename:', __filename);\n\n    // Example: Reading a file relative to the script\n    const configPath = path.join(__dirname, '",
  "Welcome to Day 6 of your interview prep! It's great to have you here. We've covered a lot of ground in the past five days, building a solid foundation in both JavaScript and Node.js.\n\nToday, we'll continue our deep dive, exploring more advanced JavaScript features, delving deeper into Node.js specifics, and touching upon some architectural and best-practice considerations. Remember, this is a discussion to understand your depth of knowledge.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: Explain the purpose and syntax of the **Optional Chaining (`?.`)** and **Nullish Coalescing (`??`)** operators in JavaScript. When would you use each?\n2.  **Answer**:\n    *   **Optional Chaining (`?.`)**: This operator allows you to safely access properties of an object that might be `null` or `undefined` without causing a `TypeError`. If a property in the chain is `null` or `undefined`, the expression short-circuits and returns `undefined` instead of throwing an error.\n    *   **Nullish Coalescing (`??`)**: This operator provides a default value for an expression only when the expression evaluates to `null` or `undefined`. It differs from the logical OR operator (`||`) because `||` treats `null`, `undefined`, `0`, `''` (empty string), and `false` as falsy, whereas `??` only treats `null` and `undefined` as \"nullish\".\n3.  **Follow-up Questions**:\n    *   What is the main difference between `??` and `||` when providing a default value?\n    *   Can optional chaining be used with function calls or array indexing?\n    *   What value does `obj?.prop` return if `obj` is an empty object `{}`?\n4.  **Follow-up Answers**:\n    *   The main difference is how they handle \"falsy\" values. `||` returns the right-hand side operand if the left-hand side is any falsy value (`0`, `''`, `false`, `null`, `undefined`, `NaN`). `??` only returns the right-hand side operand if the left-hand side is strictly `null` or `undefined`. This means `??` is safer when `0` or `''` are valid, non-default values.\n    *   Yes, optional chaining can be used with function calls (`obj.method?.()`) to safely call a method that might not exist, and with array indexing (`arr?.[0]`) to safely access an element of an array that might be `null` or `undefined`.\n    *   If `obj` is an empty object `{}`, `obj?.prop` will return `undefined`. It does not throw an error because the property `prop` simply does not exist on `obj`, and `?.` handles this gracefully.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Optional Chaining (?. )\n    const user = {\n        name: 'Alice',\n        address: {\n            street: '123 Main St'\n        },\n        contact: null\n    };\n\n    console.log(user.address?.street);         // Output: 123 Main St\n    console.log(user.contact?.email);          // Output: undefined (no error)\n    console.log(user.preferences?.theme);      // Output: undefined (no error)\n\n    // Nullish Coalescing (??)\n    const username = null;\n    const defaultName = username ?? 'Guest';\n    console.log(defaultName);                  // Output: Guest\n\n    const count = 0;\n    const itemsCount = count ?? 10;\n    console.log(itemsCount);                   // Output: 0 (because 0 is not nullish)\n\n    const emptyString = '';\n    const message = emptyString ?? 'Default Message';\n    console.log(message);                      // Output: '' (because '' is not nullish)\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain the purpose and common use cases for `Object.keys()`, `Object.values()`, and `Object.entries()` in JavaScript.\n2.  **Answer**: These static methods of the `Object` constructor provide ways to iterate over the properties of an object in different formats. They all return a new array.\n    *   **`Object.keys(obj)`**: Returns an array of a given object's own enumerable string-keyed property names.\n    *   **`Object.values(obj)`**: Returns an array of a given object's own enumerable string-keyed property values.\n    *   **`Object.entries(obj)`**: Returns an array of a given object's own enumerable string-keyed `[key, value]` pairs.\n    **Common Use Cases**:\n    *   Iterating over object properties (keys, values, or both).\n    *   Converting objects into arrays for easier manipulation with array methods (`map`, `filter`, `reduce`).\n    *   Checking if an object is empty (`Object.keys(obj).length === 0`).\n3.  **Follow-up Questions**:\n    *   Do these methods include properties from the object's prototype chain?\n    *   What happens if an object has properties whose keys are Symbols? Will `Object.keys()`, `Object.values()`, or `Object.entries()` include them?\n    *   Which of these methods would you use to create a new object from an existing one, possibly with some transformations?\n4.  **Follow-up Answers**:\n    *   No, these methods only include an object's *own* properties, not those inherited from its prototype chain.\n    *   No, these methods only include *string-keyed* properties. They will ignore properties whose keys are `Symbol`s. To get Symbol properties, you would use `Object.getOwnPropertySymbols()`.\n    *   You would typically use `Object.entries()` combined with `Array.prototype.map()` (for transformations) and then `Object.fromEntries()` (ES2019) to create a new object. For example: `Object.fromEntries(Object.entries(obj).map(([key, value]) => [key.toUpperCase(), value]))`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const user = {\n        name: 'Jane',\n        age: 25,\n        city: 'San Francisco'\n    };\n\n    console.log(Object.keys(user));   // Output: ['name', 'age', 'city']\n    console.log(Object.values(user)); // Output: ['Jane', 25, 'San Francisco']\n    console.log(Object.entries(user));\n    // Output: [['name', 'Jane'], ['age', 25], ['city', 'San Francisco']]\n\n    // Example: Check if object is empty\n    const emptyObj = {};\n    console.log(Object.keys(emptyObj).length === 0); // Output: true\n\n    // Example: Transform values using map on entries\n    const capitalizedKeys = Object.fromEntries(\n        Object.entries(user).map(([key, value]) => [key.toUpperCase(), value])\n    );\n    console.log(capitalizedKeys); // { NAME: 'Jane', AGE: 25, CITY: 'San Francisco' }\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: Define **Recursion** in programming. Provide a simple JavaScript example, like calculating a factorial or Fibonacci number, and explain how it works.\n2.  **Answer**: Recursion is a programming technique where a function calls itself, directly or indirectly, to solve a problem. It's used when a problem can be broken down into smaller, self-similar subproblems.\n    A recursive function typically has two main parts:\n    1.  **Base Case**: A condition that stops the recursion. Without a base case, the function would call itself indefinitely, leading to a stack overflow.\n    2.  **Recursive Step**: The part where the function calls itself with a modified input that moves closer to the base case.\n3.  **Follow-up Questions**:\n    *   What is a potential pitfall of using recursion, especially with deep recursion?\n    *   Can every recursive function be rewritten iteratively (using loops)?\n    *   When might recursion be a more elegant or readable solution than iteration?\n4.  **Follow-up Answers**:\n    *   The main pitfall is **stack overflow**. Each recursive call adds a frame to the call stack. If the recursion goes too deep (many calls without reaching a base case), the stack can run out of memory, causing the program to crash.\n    *   Yes, theoretically, any recursive function can be rewritten iteratively. Recursion is often a more natural way to express solutions for problems that are inherently recursive (e.g., tree traversals, fractal generation), but iterative solutions are generally more memory-efficient as they don't consume stack frames for each \"call.\"\n    *   Recursion can be more elegant and readable for problems that have a natural recursive structure, such as tree or graph traversals, mathematical sequences (like factorial, Fibonacci), or certain parsing algorithms. It often mirrors the problem's definition more directly.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Factorial Calculation\n    function factorial(n) {\n        // Base case: factorial of 0 or 1 is 1\n        if (n === 0 || n === 1) {\n            return 1;\n        }\n        // Recursive step: n * factorial(n-1)\n        return n * factorial(n - 1);\n    }\n\n    console.log(factorial(5)); // Output: 120 (5 * 4 * 3 * 2 * 1)\n    console.log(factorial(0)); // Output: 1\n\n    // Example 2: Fibonacci Sequence (returns the nth Fibonacci number)\n    function fibonacci(n) {\n        if (n <= 1) {\n            return n; // Base cases: fib(0) = 0, fib(1) = 1\n        }\n        return fibonacci(n - 1) + fibonacci(n - 2); // Recursive step\n    }\n\n    console.log(fibonacci(6)); // Output: 8 (0, 1, 1, 2, 3, 5, 8)\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: Explain the **Event Emitter pattern** in JavaScript and Node.js. How does it facilitate communication between different parts of an application?\n2.  **Answer**: The Event Emitter pattern (also known as the Observer pattern) is a design pattern that allows objects to publish (emit) events and other objects to subscribe (listen) to those events. It promotes a decoupled architecture where components can communicate without direct dependencies on each other.\n    *   **Emitter**: An object that can emit named events.\n    *   **Listener**: A function that is executed when a specific event is emitted.\n    *   **Subscription**: The process of registering a listener with an emitter for a particular event name.\n    In Node.js, the built-in `EventEmitter` class (from the `events` module) implements this pattern and is fundamental to many Node.js core modules (like `http`, `fs`, `stream`).\n3.  **Follow-up Questions**:\n    *   How do you register and unregister event listeners using the Node.js `EventEmitter`?\n    *   Can an event listener be synchronous or asynchronous? What are the implications?\n    *   What is the benefit of using an Event Emitter over direct function calls or callbacks in certain scenarios?\n4.  **Follow-up Answers**:\n    *   You register listeners using `emitter.on(eventName, listenerFunction)` or `emitter.addListener(eventName, listenerFunction)`. You unregister listeners using `emitter.off(eventName, listenerFunction)` or `emitter.removeListener(eventName, listenerFunction)`.\n    *   Event listeners can be both synchronous or asynchronous. If a listener performs synchronous, blocking work, it will block the Event Loop, potentially impacting performance. Asynchronous listeners (e.g., using `setTimeout`, Promises) allow the Event Loop to continue processing other tasks, which is generally preferred in Node.js for non-blocking operations.\n    *   The benefit is **decoupling** and **flexibility**. Instead of a component needing to know about and directly call other components, it simply emits an event. Any number of other components can listen to that event without the emitter knowing about them. This makes the system more modular, easier to extend, and less prone to breaking changes when components are modified. It's ideal for one-to-many communication.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // In Node.js (requires 'events' module)\n    const EventEmitter = require('events');\n\n    class MyCustomEmitter extends EventEmitter {}\n\n    const myEmitter = new MyCustomEmitter();\n\n    // Register a listener for 'greet' event\n    myEmitter.on('greet', (name) => {\n        console.log(`Hello, ${name}!`);\n    });\n\n    // Register another listener for 'greet' event\n    myEmitter.on('greet', (name) => {\n        console.log(`Glad to see you, ${name}.`);\n    });\n\n    // Register a listener for 'data' event\n    myEmitter.on('data', (payload) => {\n        console.log('Received data:', payload);\n    });\n\n    // Emit the 'greet' event\n    myEmitter.emit('greet', 'Alice');\n    // Output:\n    // Hello, Alice!\n    // Glad to see you, Alice.\n\n    // Emit the 'data' event\n    myEmitter.emit('data', { id: 1, value: 'some info' });\n    // Output: Received data: { id: 1, value: 'some info' }\n\n    // Remove a specific listener\n    const specificListener = (name) => console.log(`This listener will be removed for ${name}.`);\n    myEmitter.on('farewell', specificListener);\n    myEmitter.emit('farewell', 'Bob'); // Output: This listener will be removed for Bob.\n    myEmitter.off('farewell', specificListener);\n    myEmitter.emit('farewell', 'Charlie'); // No output for Charlie, listener removed\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: How do you create a very basic HTTP server in Node.js using the built-in `http` module? Provide a simple example that responds to all requests with \"Hello, World!\".\n2.  **Answer**: Node.js has a built-in `http` module that allows you to create web servers without relying on external frameworks. You use `http.createServer()` to create a server instance, which takes a callback function that executes for every incoming request. You then use `server.listen()` to start the server on a specific port.\n3.  **Follow-up Questions**:\n    *   What are the `req` and `res` objects in the server's callback function, and what are their typical roles?\n    *   How would you send a different response based on the requested URL path (e.g., `/` vs `/about`)?\n    *   What is the default port for HTTP, and why is it common practice to use ports like 3000 or 8080 for development?\n4.  **Follow-up Answers**:\n    *   The `req` (request) object is an instance of `http.IncomingMessage` and contains information about the incoming request, such as the URL, HTTP method, headers, and body. The `res` (response) object is an instance of `http.ServerResponse` and is used to send data back to the client, including setting headers, status codes, and writing the response body.\n    *   You would check `req.url` inside the request handler. For example, using `if (req.url === '/') { /* respond for root */ } else if (req.url === '/about') { /* respond for about */ }`.\n    *   The default port for HTTP is 80. Ports below 1024 are considered \"well-known ports\" and typically require administrative privileges to bind to. For development, it's common to use higher-numbered ports like 3000, 8080, 5000, etc., because they don't require special permissions and are less likely to conflict with other services.\n5.  **Code Example(s)**:\n\n    ```javascript\n    const http = require('http');\n\n    const hostname = '127.0.0.1'; // localhost\n    const port = 3000;\n\n    // Create a server instance\n    const server = http.createServer((req, res) => {\n        // Set the response HTTP header with HTTP status and Content-Type\n        res.statusCode = 200; // OK\n        res.setHeader('Content-Type', 'text/plain');\n\n        // Send the response body\n        res.end('Hello, World!\\n');\n    });\n\n    // Start the server\n    server.listen(port, hostname, () => {\n        console.log(`Server running at http://${hostname}:${port}/`);\n    });\n    ```\n\n---\n\n### **"
]