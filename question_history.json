[
  "Can you explain the key differences between `var`, `let`, and `const` in JavaScript?",
  "What are the two main categories of data types in JavaScript, and what is the fundamental difference between how they are stored and accessed?",
  "Explain the concept of \"hoisting\" in JavaScript. Provide an example where hoisting affects variable and function declarations differently.",
  "Explain the difference between the `==` (loose equality) and `===` (strict equality) operators in JavaScript. When would you prefer to use one over the other?",
  "What is \"scope\" in JavaScript? Explain the concepts of Global Scope, Function Scope, and Block Scope.",
  "What are Arrow Functions in JavaScript? List at least three key differences between arrow functions and regular function declarations/expressions.",
  "Explain the concept of the `this` keyword in JavaScript. How is its value determined?",
  "Briefly explain the concept of the Event Loop in Node.js. Why is it fundamental to Node.js's non-blocking I/O model?",
  "How do you handle errors in synchronous and asynchronous JavaScript code? Explain the use of `try...catch` and discuss its limitations with asynchronous operations.",
  "Explain what \"truthy\" and \"falsy\" values are in JavaScript. List all the explicitly \"falsy\" values in JavaScript.",
  "Describe what implicit type coercion is in JavaScript. Provide an example where it might lead to unexpected results.",
  "Explain the purpose of a `for...of` loop in JavaScript and when you would prefer to use it over a traditional `for` loop or `for...in` loop.",
  "What is an Immediately Invoked Function Expression (IIFE) in JavaScript, and what are its primary uses?",
  "Explain the purpose and return value of the `Array.prototype.map()` method. How does it differ from `Array.prototype.forEach()`?",
  "How do you add, modify, and delete properties from a JavaScript object? Provide examples for each operation.",
  "What is a callback function in JavaScript? Provide a simple example demonstrating its use with `setTimeout`.",
  "Explain the concept of the prototype chain in JavaScript. How does JavaScript achieve inheritance through this mechanism?",
  "What is a closure in JavaScript? Provide an example demonstrating how a closure can retain access to an outer function's scope.",
  "Explain what destructuring assignment is in JavaScript and provide examples for both array and object destructuring.",
  "What are Template Literals in JavaScript, and what advantages do they offer over traditional string concatenation?",
  "Explain the difference between the `null` and `undefined` data types in JavaScript. When might you encounter each?",
  "Describe the purpose of the spread (`...`) syntax and the rest (`...`) parameters in JavaScript. Provide an example for each.",
  "Explain the purpose of the `Array.prototype.filter()` method. How does it differ from `Array.prototype.map()` and `Array.prototype.forEach()`?",
  "Discuss the differences between CommonJS modules (used primarily in Node.js) and ES Modules (ESM, used in modern browsers and increasingly in Node.js). Focus on their syntax and how they handle imports/exports.",
  "What is \"Strict Mode\" in JavaScript, and why would you use `'use strict'`? List at least three specific changes or restrictions it introduces.",
  "Explain the concept of Promises in JavaScript. How do they help manage asynchronous operations more effectively than traditional callbacks, and what are their three possible states?",
  "Explain the difference between `Promise.all()` and `Promise.race()`. When would you use one over the other?",
  "In Node.js, what is the `process` object, and what are some of its key properties or methods that developers commonly interact with?",
  "Explain the difference between passing arguments by value and by reference in JavaScript functions.",
  "How do you check the data type of a variable in JavaScript? Discuss `typeof` and its known limitations.",
  "Explain the purpose of the `isNaN()` function and the global `NaN` property in JavaScript. What are some common scenarios where `NaN` might appear?",
  "Describe \"short-circuiting\" with logical operators (`&&`, `||`) in JavaScript. Provide a simple example for each.",
  "Explain the concept of `async` and `await` in JavaScript. How do they simplify asynchronous code compared to using Promises directly or traditional callbacks?",
  "Describe the difference between `Array.prototype.slice()` and `Array.prototype.splice()` methods in JavaScript. Provide use cases for each.",
  "Explain the purpose of the `Array.prototype.reduce()` method in JavaScript. How does it work, and what are its main parameters?",
  "Describe the purpose and usage of `Object.keys()`, `Object.values()`, and `Object.entries()` methods in JavaScript.",
  "Explain the differences between `String.prototype.indexOf()` and `String.prototype.includes()` methods. When would you use one over the other?",
  "In Node.js, what is the purpose of the `fs` (File System) module? Give a simple example of reading a file asynchronously.",
  "Explain the difference between `call()`, `apply()`, and `bind()` methods in JavaScript. How do they affect the `this` context of a function?",
  "Describe how the `new` keyword works in JavaScript when used with a constructor function. What does it return, and what happens behind the scenes?",
  "In JavaScript, how do you explicitly convert a string to a number, and vice versa? Provide at least two methods for each direction.",
  "Explain the primary purpose of `console.log()` and `console.dir()` in JavaScript debugging. When would you choose to use `console.dir()` over `console.log()`?",
  "The `typeof` operator is commonly used to check the data type of a variable. Explain what `typeof null` returns in JavaScript and why this is considered a \"quirk\" or a \"bug.\"",
  "In JavaScript, what is the most reliable way to determine if a given variable is an array? Why is this method preferred over others like `typeof` or `instanceof`?",
  "Explain the concept of \"method chaining\" in JavaScript. How is it implemented, and what are its primary benefits? Provide a simple code example.",
  "What are getters and setters in JavaScript objects, and why would you use them? Provide an example.",
  "In Node.js, when using CommonJS modules, what is the fundamental difference between `module.exports` and `exports`? Explain when you should use one over the other.",
  "Explain the purpose of `JSON.stringify()` and `JSON.parse()` in JavaScript. When would you use each?",
  "What is the purpose of the `package.json` file in a Node.js project? Name a few key fields you would typically find in it.",
  "Describe the difference between a primitive value and an object in JavaScript, focusing on how they are handled in terms of mutability and assignment.",
  "Explain the difference between `console.log()` and `console.error()` in Node.js (or browser). When would you choose to use `console.error()`?",
  "What are `Set` and `Map` in JavaScript? Describe a practical use case for each.",
  "Explain the difference between synchronous and asynchronous operations in JavaScript. Provide an example of each.",
  "In Node.js, what are `__dirname` and `__filename`? When are they useful?",
  "Explain the concept of recursion in JavaScript. Provide a simple example of a recursive function. What are the potential drawbacks?",
  "Describe what an Event Emitter is in Node.js. How does it facilitate an event-driven architecture? Provide a simple code example.",
  "Explain the purpose and usage of the `Object.freeze()` and `Object.seal()` methods in JavaScript. How do they differ?",
  "What is the purpose of the `Symbol` data type in JavaScript? Provide a simple use case where `Symbol` would be beneficial.",
  "Explain the concept of \"currying\" in JavaScript. Why might you use it, and what are its main benefits?",
  "In Node.js, what is the main difference between `process.nextTick()` and `setImmediate()`? When would you typically use one over the other?",
  "Describe what a \"middleware\" function is in the context of a Node.js web framework like Express.js. How does it typically receive control and pass it on?",
  "Explain the concept of JavaScript Generators. How do they differ from regular functions, and what is the `yield` keyword used for?",
  "What are Node.js `Buffer`s, and why are they necessary? Provide a simple example of creating a `Buffer` from a string.",
  "What are optional chaining (`?.`) and nullish coalescing (`??`) operators in JavaScript? Provide a scenario where each would be particularly useful.",
  "How do you add event listeners to DOM elements in JavaScript? Provide an example of adding a click event listener to a button.",
  "Explain the purpose of the `super` keyword in ES6 classes. When and why would you use it in a class constructor and in other methods?",
  "What is a \"pure function\" in JavaScript, and what are its main characteristics? Why are pure functions considered beneficial in programming?",
  "Explain the concept of \"event delegation\" in JavaScript. Why is it beneficial, especially when dealing with a large number of dynamic elements?",
  "Describe what Node.js Streams are. What are the different types of streams, and why are they important for I/O operations in Node.js?",
  "Explain the difference between the `in` operator and the `Object.prototype.hasOwnProperty()` method in JavaScript. When would you typically use one over the other?",
  "What is the purpose of the `debugger` keyword in JavaScript, and how does it assist in debugging your code?",
  "Explain the difference between `let` and `const` in JavaScript, specifically focusing on how they handle reassignment versus the mutability of the *value* they hold.",
  "Explain what the `typeof` operator returns for functions and arrays in JavaScript. Are these results always intuitive, particularly for arrays?",
  "What is the purpose of the `Node Package Manager (npm)`? How do you typically install a third-party package for a Node.js project using `npm`?\n\n2.  **Answer**:\n    `npm` (Node Package Manager) is the default package manager for Node.js. Its primary purpose is to help JavaScript developers share and reuse code. It allows you to:\n    *   Discover and install packages (libraries, frameworks, tools) published by other developers.\n    *   Manage dependencies for your own projects, ensuring that all necessary libraries are installed and at the correct versions.\n    *   Run scripts defined in your `package.json` file.\n    *   Publish your own packages to the npm registry.\n\n    To install a third-party package for a Node.js project, you use the `npm install` command. If you want to add it as a dependency to your project (so it's listed in `package.json` and can be reinstalled later), you typically use the `--save` or `--save-dev` flags (or their shorthand `-S` or `-D`).\n\n3.  **Follow-up Questions**:\n    *   What's the difference between `npm install <package-name>` and `npm install <package-name> --save-dev`?\n    *   What command would you use to install all project dependencies listed in a `package.json` file?\n    *   Can you name another popular package manager for Node.js besides `npm`?\n\n4.  **Follow-up Answers**:\n    *   `npm install <package-name>` installs the package into `node_modules` but does not automatically add it to your `package.json` dependencies (though modern `npm` versions often default to `--save`). `npm install <package-name> --save-dev` (or `-D`) installs the package and adds it to the `devDependencies` section of your `package.json`. `devDependencies` are typically for packages needed during development (e.g., testing frameworks, build tools), while `dependencies` are for packages required at runtime.\n    *   To install all project dependencies listed in `package.json`, you would simply run `npm install` (or `npm i`) without any package name.\n    *   Another popular package manager for Node.js is `Yarn`.\n\n5.  **Code Example(s)**:\n\n    ```bash\n    # Install a package and save it as a regular dependency\n    npm install express\n\n    # Install a package and save it as a dev dependency\n    npm install jest --save-dev\n\n    # Install all dependencies from package.json\n    npm install\n    ```\n\n---\n\n### **Question 2 (Basic)**\n\n1.  **Main Question**: Explain the concept of `event propagation` (bubbling and capturing) in the browser DOM. Why is it important for handling user interactions efficiently?\n\n2.  **Answer**:\n    Event propagation describes the order in which events fire on elements nested within each other in the DOM (Document Object Model) tree. When an event occurs on an element (e.g., a click on a button inside a `div`), it doesn't just trigger listeners on that element. Instead, it propagates through the DOM in two phases:\n\n    *   **Capturing Phase (Trickle Down)**: The event starts from the `window` object, then travels down through the ancestor elements to the target element. Listeners set to capture the event will fire during this phase.\n    *   **Bubbling Phase (Bubble Up)**: After reaching the target element, the event then bubbles up from the target element back to the `window` object, triggering listeners on its ancestors along the way. Most event listeners are set to fire during the bubbling phase by default.\n\n    It's important because it allows for **event delegation**. Instead of attaching many event listeners to individual child elements, you can attach a single listener to a parent element. This listener can then identify which child element triggered the event (using `event.target`) and react accordingly. This is more efficient for performance and memory, especially with dynamic lists of elements.\n\n3.  **Follow-up Questions**:\n    *   How can you stop event propagation at a certain point?\n    *   Which phase (bubbling or capturing) is the default for `addEventListener`?\n    *   What is `event.target` and `event.currentTarget` in the context of event propagation?\n\n4.  **Follow-up Answers**:\n    *   You can stop event propagation using `event.stopPropagation()`. This prevents the event from continuing its journey up (or down) the DOM tree.\n    *   The bubbling phase is the default for `addEventListener`. To listen during the capturing phase, you pass `true` as the third argument to `addEventListener` (e.g., `element.addEventListener('click', handler, true)`).\n    *   `event.target` refers to the actual element that triggered the event (the \"innermost\" element). `event.currentTarget` refers to the element on which the event listener was attached.\n\n5.  **Code Example(s)**:\n\n    ```html\n    <div id=\"parent\">\n      <button id=\"child\">Click Me</button>\n    </div>\n\n    <script>\n      const parent = document.getElementById('parent');\n      const child = document.getElementById('child');\n\n      parent.addEventListener('click', () => {\n        console.log('Parent Clicked (Bubbling)');\n      });\n\n      child.addEventListener('click', (event) => {\n        console.log('Child Clicked');\n        // event.stopPropagation(); // Uncomment to stop bubbling\n      });\n\n      // Example of capturing phase listener\n      parent.addEventListener('click', () => {\n        console.log('Parent Clicked (Capturing)');\n      }, true); // The 'true' argument makes it a capturing listener\n    </script>\n    ```\n    *Output without `stopPropagation()`*: Parent Clicked (Capturing), Child Clicked, Parent Clicked (Bubbling)\n    *Output with `stopPropagation()` uncommented*: Parent Clicked (Capturing), Child Clicked\n\n---\n\n### **Question 3 (Basic)**\n\n1.  **Main Question**: Describe the difference between `localStorage` and `sessionStorage` in web browsers. When would you typically use each?\n\n2.  **Answer**:\n    Both `localStorage` and `sessionStorage` are mechanisms for web browsers to store key-value pairs locally within the user's browser, providing a way for web applications to persist data across sessions or browser tabs. They are part of the Web Storage API.\n\n    The key differences lie in their **persistence** and **scope**:\n\n    *   **`localStorage`**:\n        *   **Persistence**: Data stored in `localStorage` persists even after the browser window is closed, the user navigates away, or the computer is restarted. It has no expiration date.\n        *   **Scope**: Data is available across all tabs and windows from the same origin (same protocol, host, and port).\n        *   **Use Case**: Ideal for storing data that needs to be available for a long time, such as user preferences (e.g., dark mode setting), user's login status (though sensitive data like tokens should be handled carefully), or cached application data that doesn't need to be refreshed frequently.\n\n    *   **`sessionStorage`**:\n        *   **Persistence**: Data stored in `sessionStorage` is only available for the duration of the browser session (i.e., until the browser tab or window is closed). If the user closes the tab and reopens it, the data is lost.\n        *   **Scope**: Data is restricted to the specific tab or window in which it was created. If you open the same application in a new tab, it will have its own separate `sessionStorage`.\n        *   **Use Case**: Suitable for storing temporary session-specific data, such as shopping cart contents during a single checkout flow, form input data that needs to persist across page reloads within the same session, or user navigation history for a specific session.\n\n3.  **Follow-up Questions**:\n    *   What are the limitations of `localStorage` and `sessionStorage` regarding data size and data type?\n    *   How do you add, retrieve, and remove data from `localStorage`?\n    *   Are these storage mechanisms secure for sensitive user data like passwords or credit card numbers? Why or why not?\n\n4.  **Follow-up Answers**:\n    *   Both `localStorage` and `sessionStorage` typically have a storage limit of around 5-10 MB (depending on the browser). They can only store strings. If you want to store objects or arrays, you must first convert them to JSON strings using `JSON.stringify()` before storing, and `JSON.parse()` when retrieving.\n    *   To add data: `localStorage.setItem('key', 'value');`\n        To retrieve data: `localStorage.getItem('key');`\n        To remove data: `localStorage.removeItem('key');`\n        To clear all data: `localStorage.clear();`\n    *   No, they are generally not secure for sensitive user data like passwords or credit card numbers. Data stored in `localStorage` and `sessionStorage` is accessible via JavaScript, making it vulnerable to Cross-Site Scripting (XSS) attacks. If an attacker can inject malicious JavaScript, they can easily read or modify this data. For sensitive data, more secure methods like HTTP-only cookies or server-side storage are preferred.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Using localStorage\n    localStorage.setItem('username', 'Alice');\n    console.log('Local Storage Username:', localStorage.getItem('username'));\n    // Data persists even after browser close\n\n    // Using sessionStorage\n    sessionStorage.setItem('cartId', '12345');\n    console.log('Session Storage Cart ID:', sessionStorage.getItem('cartId'));\n    // Data will be lost when the tab is closed\n    ```\n\n---\n\n### **Question 4 (Basic)**\n\n1.  **Main Question**: What is the purpose of `Object.assign()` in JavaScript? How does it differ from the spread operator (`...`) when merging objects?\n\n2.  **Answer**:\n    `Object.assign()` is a static method used to copy the values of all enumerable own properties from one or more source objects to a target object. It returns the target object. Its primary purpose is to merge objects or to create shallow copies of objects.\n\n    **Differences from the spread operator (`...`) for object merging:**\n\n    *   **Syntax**: `Object.assign()` is a method call, while the spread operator is a syntax feature.\n    *   **Return Value**: `Object.assign()` modifies and returns the *target object* itself. The spread operator creates a *new object* without modifying any of the original objects.\n    *   **Immutability**: The spread operator inherently promotes immutability by creating a new object. `Object.assign()` can be used for immutability if you pass an empty object `{}` as the first argument, but it can also mutate an existing object if that object is passed as the target.\n    *   **Browser/Node.js Support**: `Object.assign()` has wider browser support than the spread operator (which is an ES2015/ES6 feature). However, modern environments largely support both.\n\n    Both perform a **shallow copy**. This means if the source object contains nested objects or arrays, only references to those nested structures are copied, not deep copies. Modifying a nested structure in the copied object will also affect the original.\n\n3.  **Follow-up Questions**:\n    *   Can `Object.assign()` be used to create a deep copy of an object? Why or why not?\n    *   What happens if multiple source objects have the same property key when using `Object.assign()`?\n    *   When would you prefer using the spread operator over `Object.assign()` for merging?\n\n4.  **Follow-up Answers**:\n    *   No, `Object.assign()` cannot be used to create a deep copy. It only performs a shallow copy. If a property's value is an object or an array, `Object.assign()` copies the *reference* to that object/array, not a new copy of it.\n    *   If multiple source objects have the same property key, the properties from later source objects in the argument list will overwrite the properties from earlier source objects.\n    *   You would prefer the spread operator when you want to create a new object without mutating any of the original objects (immutability), or when you prefer a more concise and readable syntax for simple merging operations. It's generally considered more idiomatic for modern JavaScript for non-mutating merges.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { b: 3, c: 4 };\n\n    // Using Object.assign() to merge into a new object (immutable way)\n    const mergedAssign = Object.assign({}, obj1, obj2);\n    console.log('Object.assign() merge:', mergedAssign); // { a: 1, b: 3, c: 4 }\n    console.log('Original obj1 after assign:', obj1); // { a: 1, b: 2 } (not mutated)\n\n    // Using Object.assign() to mutate an existing object\n    const targetObj = { x: 10 };\n    Object.assign(targetObj, obj1);\n    console.log('Object.assign() mutate:', targetObj); // { x: 10, a: 1, b: 2 }\n\n    // Using spread operator\n    const mergedSpread = { ...obj1, ...obj2 };\n    console.log('Spread operator merge:', mergedSpread); // { a: 1, b: 3, c: 4 }\n    console.log('Original obj1 after spread:', obj1); // { a: 1, b: 2 } (not mutated)\n\n    // Shallow copy example for both\n    const original = { a: 1, nested: { b: 2 } };\n    const copiedAssign = Object.assign({}, original);\n    const copiedSpread = { ...original };\n\n    copiedAssign.nested.b = 3;\n    console.log('Original after assign nested change:', original.nested.b); // 3 (shallow copy)\n\n    original.nested.b = 2; // Reset for next test\n    copiedSpread.nested.b = 4;\n    console.log('Original after spread nested change:', original.nested.b); // 4 (shallow copy)\n    ```\n\n---\n\n### **Question 5 (Intermediate)**\n\n1.  **Main Question**: Explain the concept of `module caching` in Node.js. Why is it important, and how does it affect `require()` calls?\n\n2.  **Answer**:\n    In Node.js, once a module is loaded (i.e., its code is executed) using `require()`, it is cached. This means that subsequent `require()` calls for the *same module* will not re-execute the module's code; instead, they will return the *cached export object* of that module.\n\n    **Why it's important:**\n    *   **Performance**: Prevents redundant file I/O and code execution, making applications faster.\n    *   **Consistency**: Ensures that all parts of your application that `require` the same module are working with the exact same instance of that module. This is crucial for modules that manage state (e.g., a database connection pool, a singleton configuration object). Without caching, each `require` would create a new instance, leading to unpredictable behavior and resource waste.\n\n    **How it affects `require()` calls**:\n    *   The first time `require('./myModule.js')` is called, Node.js finds the file, executes its code, and stores the `module.exports` object in its cache.\n    *   Any subsequent `require('./myModule.js')` call will simply return the cached `module.exports` object immediately, without re-reading the file or re-executing the code.\n\n3.  **Follow-up Questions**:\n    *   Where is the module cache stored in Node.js, and how can you inspect it?\n    *   Is there a way to clear a module from the cache, and why might you want to do that?\n    *   Does module caching apply to built-in Node.js modules (like `fs` or `http`) as well?\n\n4.  **Follow-up Answers**:\n    *   The module cache is stored in `require.cache`. It's an object where keys are the resolved file paths of the modules and values are the `module` objects. You can inspect it by logging `require.cache`.\n    *   Yes, you can delete a module from the cache by deleting its entry from `require.cache`. For example, `delete require.cache[require.resolve('./myModule.js')]`. This is typically done in development environments (e.g., for hot-reloading) or in testing frameworks to ensure a fresh module instance for each test. It's generally not recommended in production as it can lead to unexpected behavior if not handled carefully.\n    *   Yes, module caching applies to built-in Node.js modules as well. Once `require('fs')` is called, the `fs` module is cached, and subsequent calls will return the same instance.\n\n5.  **Code Example(s)**:\n\n    `my-module.js`:\n    ```javascript\n    console.log('My module is being loaded!');\n    let counter = 0;\n    module.exports = {\n      increment: () => ++counter,\n      getCounter: () => counter\n    };\n    ```\n\n    `app.js`:\n    ```javascript\n    const myModule1 = require('./my-module');\n    const myModule2 = require('./my-module');\n\n    console.log('Module 1 counter:', myModule1.getCounter()); // 0\n    myModule1.increment();\n    console.log('Module 1 counter after increment:', myModule1.getCounter()); // 1\n    console.log('Module 2 counter:', myModule2.getCounter()); // 1 (because it's the same cached instance)\n\n    // Verify they are the exact same object reference\n    console.log('Are myModule1 and myModule2 the same object?', myModule1 === myModule2); // true\n\n    // Example of clearing cache (usually for specific dev/test scenarios)\n    const modulePath = require.resolve('./my-module');\n    delete require.cache[modulePath];\n    console.log('\\n--- Cache cleared for my-module ---');\n\n    const myModule3 = require('./my-module'); // This will re-execute my-module.js\n    console.log('My module is being loaded!'); // This will print again\n    console.log('Module 3 counter:', myModule3.getCounter()); // 0 (new instance, new counter)\n    ```\n\n---\n\n### **Question 6 (Intermediate)**\n\n1.  **Main Question**: In Node.js, what are environment variables, and why are they commonly used for configuration? How can you access them in a Node.js application?\n\n2.  **Answer**:\n    Environment variables are dynamic named values that can affect the way running processes behave on a computer. They are part of the operating system's environment and are external to the application's source code.\n\n    **Why they are used for configuration**:\n    *   **Security**: Sensitive information (like API keys, database credentials, secret keys) should never be hardcoded directly into the source code. Environment variables allow you to keep these secrets out of your version control system (e.g., Git) and provide them at runtime.\n    *   **Flexibility**: They enable easy configuration changes without modifying and redeploying the application code. You can have different configurations for different environments (development, testing, production) simply by setting different environment variables.\n    *   **Portability**: They provide a standardized way to pass configuration to applications, regardless of the deployment platform (e.g., local machine, Docker container, cloud server).\n\n    In a Node.js application, you can access environment variables through the global `process.env` object. This object is a simple JavaScript object where keys are the environment variable names and values are their corresponding string values.\n\n3.  **Follow-up Questions**:\n    *   What is a common practice to manage environment variables in a development environment without polluting the system's global environment?\n    *   What happens if you try to access an environment variable that hasn't been set?\n    *   Why should environment variables always be treated as strings, even if they represent numbers or booleans?\n\n4.  **Follow-up Answers**:\n    *   A common practice is to use a `.env` file (e.g., with the `dotenv` npm package). This file stores key-value pairs locally, and the `dotenv` package loads these variables into `process.env` when your application starts, without affecting the global system environment. The `.env` file itself is typically excluded from version control using `.gitignore`.\n    *   If you try to access an environment variable that hasn't been set, `process.env.<VARIABLE_NAME>` will return `undefined`. Your application code should include checks or provide default values for such cases.\n    *   Environment variables are always strings because they are passed as plain text by the operating system. Even if you set `PORT=3000`, `process.env.PORT` will be the string `\"3000\"`, not the number `3000`. You need to explicitly parse them to the desired type (e.g., `parseInt(process.env.PORT, 10)` or `process.env.DEBUG === 'true'`).\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // app.js\n    // Accessing environment variables\n    const port = process.env.PORT || 3000;\n    const dbHost = process.env.DB_HOST || 'localhost';\n    const dbUser = process.env.DB_USER; // This might be undefined if not set\n\n    console.log(`Application running on port: ${port}`);\n    console.log(`Database Host: ${dbHost}`);\n    console.log(`Database User: ${dbUser}`);\n\n    if (process.env.NODE_ENV === 'production') {\n      console.log('Running in production mode.');\n    } else {\n      console.log('Running in development or other mode.');\n    }\n    ```\n\n    To run this, you'd set environment variables in your terminal:\n    ```bash\n    # On Linux/macOS\n    PORT=8080 DB_HOST=myprod.db.com NODE_ENV=production node app.js\n\n    # On Windows (Command Prompt)\n    set PORT=8080&& set DB_HOST=myprod.db.com&& set NODE_ENV=production&& node app.js\n\n    # On Windows (PowerShell)\n    $env:PORT=8080; $env:DB_HOST='myprod.db.com'; $env:NODE_ENV='production'; node app.js\n    ```\n\n---\n\n### **Question 7 (Intermediate)**\n\n1.  **Main Question**: Describe the difference between `HTTP GET` and `HTTP POST` requests. When would you typically use one over the other?\n\n2.  **Answer**:\n    `GET` and `POST` are two of the most common HTTP methods used to interact with web resources.\n\n    *   **HTTP GET**:\n        *   **Purpose**: Used to *request* data from a specified resource. It should only retrieve data and have no other effect on the data (i.e., it should be idempotent and safe).\n        *   **Data Transmission**: Parameters are sent in the URL as query strings (e.g., `/api/users?id=123`).\n        *   **Visibility**: Parameters are visible in the URL, browser history, and server logs.\n        *   **Caching**: Can be cached by browsers and proxies.\n        *   **Bookmarkable**: Can be bookmarked.\n        *   **Length Limits**: Has practical URL length limits (though not a strict HTTP limit).\n        *   **Use Cases**: Retrieving a webpage, fetching a list of items, querying specific data based on IDs or filters.\n\n    *   **HTTP POST**:\n        *   **Purpose**: Used to *submit* data to be processed to a specified resource. It typically creates a new resource or updates an existing one on the server.\n        *   **Data Transmission**: Parameters are sent in the request body.\n        *   **Visibility**: Parameters are not visible in the URL.\n        *   **Caching**: Cannot be cached.\n        *   **Bookmarkable**: Cannot be bookmarked directly.\n        *   **Length Limits**: No practical data length limits (limited by server/client resources).\n        *   **Use Cases**: Submitting a form (e.g., user registration, login), uploading a file, sending complex JSON data to create a new record.\n\n    **When to use each**:\n    *   Use `GET` when you want to **read or retrieve data** and the request has no side effects on the server's state.\n    *   Use `POST` when you want to **send data to the server to create or update a resource**, or when the request has side effects. Also, use `POST` for sensitive data (like passwords) or large amounts of data.\n\n3.  **Follow-up Questions**:\n    *   What are \"safe\" and \"idempotent\" methods in HTTP? Which of `GET` and `POST` fall into these categories?\n    *   Why is it generally bad practice to send sensitive data (like passwords) using a `GET` request?\n    *   Can a `POST` request return data, similar to a `GET` request?\n\n4.  **Follow-up Answers**:\n    *   **Safe methods**: Do not alter the state of the server. `GET` is a safe method. `POST` is not.\n    *   **Idempotent methods**: Produce the same result on the server if executed multiple times. `GET` is idempotent. `POST` is generally *not* idempotent (e.g., submitting a form multiple times might create multiple new resources).\n    *   It's bad practice to send sensitive data via `GET` because the data is exposed in the URL, browser history, and server logs. This makes it vulnerable to shoulder surfing, being intercepted, or being stored in plain text in various places.\n    *   Yes, a `POST` request can and often does return data. For example, after successfully creating a new user (via `POST`), the server might respond with the newly created user object, including its ID, or a success message.\n\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example Node.js Express server demonstrating GET and POST\n    const express = require('express');\n    const app = express();\n    const port = 3000;\n\n    app.use(express.json()); // Middleware to parse JSON request bodies\n\n    let products = [{ id: 1, name: 'Laptop', price: 1200 }];\n\n    // GET request: Retrieve all products\n    app.get('/products', (req, res) => {\n      console.log('GET /products requested.');\n      res.json(products);\n    });\n\n    // POST request: Add a new product\n    app.post('/products', (req, res) => {\n      const newProduct = req.body;\n      if (newProduct && newProduct.name && newProduct.price) {\n        newProduct.id = products.length > 0 ? Math.max(...products.map(p => p.id)) + 1 : 1;\n        products.push(newProduct);\n        console.log('POST /products: New product added:', newProduct);\n        res.status(201).json(newProduct); // 201 Created\n      } else {\n        res.status(400).send('Invalid product data.'); // 400 Bad Request\n      }\n    });\n\n    app.listen(port, () => {\n      console.log(`Server listening at http://localhost:${port}`);\n    });\n    ```\n    *To test:*\n    `GET`: `http://localhost:3000/products`\n    `POST`: `http://localhost:30"
]