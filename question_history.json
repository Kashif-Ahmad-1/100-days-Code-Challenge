[
  "Welcome to Day 1 of your interview prep! It's great to have you here. Today, we'll dive into some fundamental concepts in JavaScript and Node.js. Don't worry, we'll start with the basics and gradually ramp up the difficulty. Think of this as a friendly discussion to gauge your understanding.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: Can you explain the key differences between `var`, `let`, and `const` in JavaScript?\n2.  **Answer**:\n    *   **`var`**: Function-scoped and hoisted. Variables declared with `var` are accessible throughout the function they are declared in, regardless of block scope. They are also \"hoisted\" to the top of their function or global scope, meaning you can use them before they are declared (though their value will be `undefined` until the declaration is reached).\n    *   **`let`**: Block-scoped and not hoisted (in the sense that they are in a \"temporal dead zone\"). `let` limits the variable's scope to the block (e.g., inside `if` statements, `for` loops, or curly braces `{}`) where it is declared. You cannot access a `let` variable before its declaration in code.\n    *   **`const`**: Block-scoped and not hoisted, similar to `let`. The main difference is that `const` declares a constant, meaning its value cannot be reassigned after initialization. However, for objects and arrays declared with `const`, their *properties* or *elements* can still be modified.\n3.  **Follow-up Questions**:\n    *   Which keyword would you typically use for loop counters, and why?\n    *   What happens if you try to reassign a `const` variable?\n    *   Can you declare a `const` variable without initializing it?\n4.  **Follow-up Answers**:\n    *   For loop counters, `let` is typically used because it provides block-scoping. This ensures that the loop counter variable is confined to the loop's scope, preventing unintended side effects or conflicts with variables outside the loop.\n    *   If you try to reassign a `const` variable, JavaScript will throw a `TypeError` because `const` values cannot be reassigned.\n    *   No, you cannot declare a `const` variable without initializing it. It must be assigned a value at the time of declaration, otherwise, it will result in a `SyntaxError`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // var example\n    function varScope() {\n        if (true) {\n            var x = 10;\n        }\n        console.log(x); // Output: 10 (var is function-scoped)\n    }\n    varScope();\n\n    // let/const example\n    function letConstScope() {\n        if (true) {\n            let y = 20;\n            const z = 30;\n            // z = 31; // This would throw a TypeError\n            console.log(y, z); // Output: 20 30\n        }\n        // console.log(y); // This would throw a ReferenceError (y is not defined)\n        // console.log(z); // This would throw a ReferenceError (z is not defined)\n    }\n    letConstScope();\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: What are the primitive data types in JavaScript?\n2.  **Answer**: Primitive data types are basic, immutable values. In JavaScript, there are seven primitive data types:\n    *   `string`: Represents text (e.g., `'hello'`, `\"world\"`).\n    *   `number`: Represents both integers and floating-point numbers (e.g., `10`, `3.14`).\n    *   `boolean`: Represents a logical entity (`true` or `false`).\n    *   `undefined`: Represents a variable that has been declared but not yet assigned a value.\n    *   `null`: Represents the intentional absence of any object value. It's a primitive value.\n    *   `symbol`: (ES6) Represents a unique identifier. Used for unique object property keys.\n    *   `bigint`: (ES2020) Represents integers with arbitrary precision (larger than `2^53 - 1`).\n3.  **Follow-up Questions**:\n    *   Is `null` an object? Explain `typeof null`.\n    *   What is the difference between `undefined` and `null`?\n    *   Can you give an example where `symbol` would be useful?\n4.  **Follow-up Answers**:\n    *   No, `null` is not an object. The `typeof null` returning `'object'` is a long-standing bug in JavaScript that has been maintained for backward compatibility. Conceptually, `null` is a primitive value representing the intentional absence of a value.\n    *   `undefined` means a variable has been declared but not assigned a value, or a function argument that was not provided. `null` is an assignment value, meaning it can be assigned to a variable as a representation of \"no value\" or \"empty.\"\n    *   `Symbol` is useful for creating unique property keys in objects to avoid naming collisions, especially when extending objects with properties that might conflict with existing or future properties. For example, a third-party library might add a property to an object using a `Symbol` to ensure it doesn't overwrite any existing string-named properties.\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log(typeof \"hello\");    // string\n    console.log(typeof 123);        // number\n    console.log(typeof true);       // boolean\n    console.log(typeof undefined);  // undefined\n    console.log(typeof null);       // object (historical bug)\n    console.log(typeof Symbol('id')); // symbol\n    console.log(typeof 10n);        // bigint\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: Explain the difference between `==` (loose equality) and `===` (strict equality) in JavaScript.\n2.  **Answer**:\n    *   **`==` (Loose Equality)**: Compares two values for equality *after* performing type coercion. This means if the two values are of different types, JavaScript will try to convert one or both values to a common type before making the comparison. This can lead to unexpected results.\n    *   **`===` (Strict Equality)**: Compares two values for equality *without* performing any type coercion. It returns `true` only if both the value *and* the type are the same. This is generally recommended for predictable comparisons.\n3.  **Follow-up Questions**:\n    *   When might `==` be useful, if ever?\n    *   What is the result of `null == undefined` and `null === undefined`? Why?\n    *   How does `NaN` behave with both `==` and `===`?\n4.  **Follow-up Answers**:\n    *   While generally discouraged due to its unpredictable nature, `==` can sometimes be used for quick checks where type coercion is explicitly desired, such as checking if a variable is `null` or `undefined` (`value == null` will return true for both `null` and `undefined`). However, for most cases, strict equality is safer.\n    *   `null == undefined` is `true` because `==` performs type coercion, and they are considered loosely equal. `null === undefined` is `false` because their types are different (`null` is `null`, `undefined` is `undefined`).\n    *   `NaN` (Not-a-Number) is unique because it is not equal to itself using either `==` or `===`. `NaN == NaN` is `false`, and `NaN === NaN` is also `false`. To check if a value is `NaN`, you should use `isNaN()` or `Number.isNaN()`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    console.log(5 == '5');   // true (type coercion: string '5' becomes number 5)\n    console.log(5 === '5');  // false (different types: number vs string)\n\n    console.log(null == undefined); // true\n    console.log(null === undefined); // false\n\n    console.log(0 == false); // true\n    console.log(0 === false); // false\n\n    console.log(NaN == NaN); // false\n    console.log(NaN === NaN); // false\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: How do you declare a function in JavaScript? Provide at least two common ways.\n2.  **Answer**: There are several common ways to declare functions in JavaScript:\n    *   **Function Declaration**: The traditional way, where you use the `function` keyword followed by the function name, parameters, and body. These are hoisted.\n    *   **Function Expression**: Assigning an anonymous or named function to a variable. These are not hoisted in the same way; the variable declaration is hoisted, but the function assignment itself is not.\n    *   **Arrow Function (ES6)**: A more concise syntax for writing function expressions. They have lexical `this` binding and are often used for shorter, non-method functions.\n3.  **Follow-up Questions**:\n    *   What is function hoisting? How does it apply to function declarations vs. function expressions?\n    *   When would you choose an arrow function over a regular function expression?\n    *   Can you have a named function expression? What's the benefit?\n4.  **Follow-up Answers**:\n    *   **Function Hoisting**: Function declarations are hoisted to the top of their scope, meaning you can call them before they are declared in the code. Function expressions (and arrow functions) are not hoisted in the same way; their variable declaration is hoisted, but the function definition itself is not, so you cannot call them before the line where they are assigned.\n    *   Arrow functions are generally preferred for shorter, single-expression functions, or when you need to preserve the `this` context from the surrounding lexical scope (e.g., inside callback functions for array methods or event handlers).\n    *   Yes, you can have a named function expression (e.g., `const myFunc = function myFuncName() {}`). The benefit is that the `myFuncName` name is available within the function's own scope for recursion or for clearer debugging stack traces.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // 1. Function Declaration\n    function greet(name) {\n        return `Hello, ${name}!`;\n    }\n    console.log(greet('Alice')); // Output: Hello, Alice!\n\n    // 2. Function Expression\n    const sayHi = function(name) {\n        return `Hi, ${name}!`;\n    };\n    console.log(sayHi('Bob')); // Output: Hi, Bob!\n\n    // 3. Arrow Function\n    const farewell = (name) => `Goodbye, ${name}!`;\n    console.log(farewell('Charlie')); // Output: Goodbye, Charlie!\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: What is \"scope\" in JavaScript, and what are the main types of scope?\n2.  **Answer**: Scope defines the accessibility of variables, functions, and objects in some particular part of your code. It determines where in your program a variable or function can be used or referenced. The main types of scope are:\n    *   **Global Scope**: Variables declared outside of any function or block. They are accessible from anywhere in the JavaScript code.\n    *   **Function (Local) Scope**: Variables declared inside a function. They are only accessible within that function.\n    *   **Block Scope (ES6 `let`/`const`)**: Variables declared with `let` or `const` inside a block (e.g., `if` statements, `for` loops, or any pair of `{}`) are only accessible within that block.\n3.  **Follow-up Questions**:\n    *   Why is it generally considered bad practice to use too many global variables?\n    *   Can a variable declared in an inner function access variables from its outer function?\n    *   What is lexical scope?\n4.  **Follow-up Answers**:\n    *   Too many global variables can lead to naming collisions, making code harder to maintain and debug, especially in large applications or when integrating with third-party libraries. They also increase the risk of unintended side effects.\n    *   Yes, a variable declared in an inner function can access variables from its outer (enclosing) function's scope. This is a fundamental concept related to closures.\n    *   Lexical scope (or static scope) means that the scope of a variable is determined at the time of writing the code (lexical analysis), not at runtime. This means that a function's access to variables from its outer scope is fixed by where it is defined in the code, not by where it is called.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global Scope\n    const globalVar = \"I'm global\";\n\n    function outerFunction() {\n        // Function Scope (outerFunction's scope)\n        const outerVar = \"I'm in outerFunction\";\n\n        if (true) {\n            // Block Scope\n            let blockVar = \"I'm in a block\";\n            console.log(globalVar);  // Accessible\n            console.log(outerVar);   // Accessible\n            console.log(blockVar);   // Accessible\n        }\n        // console.log(blockVar); // ReferenceError: blockVar is not defined\n\n        function innerFunction() {\n            // Function Scope (innerFunction's scope)\n            const innerVar = \"I'm in innerFunction\";\n            console.log(globalVar);  // Accessible\n            console.log(outerVar);   // Accessible (due to lexical scope)\n            console.log(innerVar);   // Accessible\n        }\n        innerFunction();\n    }\n    outerFunction();\n    // console.log(outerVar); // ReferenceError: outerVar is not defined\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: What is \"hoisting\" in JavaScript? Provide an example for variables and functions.\n2.  **Answer**: Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, *before* code execution.\n    *   **Variable Hoisting (`var`)**: Only the declaration is hoisted, not the initialization. Variables declared with `var` are initialized with `undefined` when hoisted.\n    *   **Function Hoisting**: Entire function declarations are hoisted, meaning you can call a function declared this way before its actual definition in the code. Function expressions and arrow functions are not hoisted in the same manner.\n3.  **Follow-up Questions**:\n    *   Does `let` or `const` hoisting behave differently from `var`?\n    *   What is the \"Temporal Dead Zone\" (TDZ) in relation to hoisting?\n    *   Why is understanding hoisting important for writing predictable code?\n4.  **Follow-up Answers**:\n    *   `let` and `const` declarations are also hoisted, but they are not initialized with `undefined`. Instead, they remain in a \"Temporal Dead Zone\" (TDZ) until their declaration is actually executed. Accessing them before their declaration results in a `ReferenceError`.\n    *   The \"Temporal Dead Zone\" (TDZ) is the period between the start of a block and the declaration of `let` or `const` variables within that block. During this time, the variables cannot be accessed, even though they are technically hoisted.\n    *   Understanding hoisting is crucial to avoid unexpected `undefined` values or `ReferenceError`s. It helps write more predictable and maintainable code by encouraging declarations at the top of their scope or using `let`/`const` which enforce declaration before use.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Variable Hoisting with var\n    console.log(myVar); // Output: undefined (declaration is hoisted)\n    var myVar = 10;\n    console.log(myVar); // Output: 10\n\n    // Function Hoisting\n    sayHello(); // Output: Hello! (entire function is hoisted)\n    function sayHello() {\n        console.log(\"Hello!\");\n    }\n\n    // Example with let/const (TDZ)\n    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization\n    let myLet = 20;\n    console.log(myLet); // Output: 20\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: How do you add, remove, and modify elements in a JavaScript array? Provide common methods.\n2.  **Answer**:\n    *   **Adding Elements**:\n        *   `push()`: Adds one or more elements to the *end* of an array and returns the new length.\n        *   `unshift()`: Adds one or more elements to the *beginning* of an array and returns the new length.\n    *   **Removing Elements**:\n        *   `pop()`: Removes the *last* element from an array and returns that element.\n        *   `shift()`: Removes the *first* element from an array and returns that element.\n        *   `splice()`: A versatile method that can add, remove, or replace elements at any position.\n    *   **Modifying Elements**:\n        *   Direct Assignment: Access an element by its index and assign a new value (e.g., `arr[index] = newValue`).\n        *   `splice()`: Can also be used to replace elements by specifying 0 for elements to delete and providing new elements.\n3.  **Follow-up Questions**:\n    *   Which of these methods modify the original array in place?\n    *   How would you add an element at a specific index without removing existing elements using `splice()`?\n    *   What is the difference between `splice()` and `slice()`?\n4.  **Follow-up Answers**:\n    *   `push()`, `unshift()`, `pop()`, `shift()`, and `splice()` all modify the original array in place.\n    *   To add an element at a specific index without removing existing elements using `splice()`, you'd set the `deleteCount` argument to `0`. For example, `arr.splice(index, 0, newElement)`.\n    *   `splice()` modifies the original array by adding/removing/replacing elements and returns the removed elements. `slice()` creates a *new* array containing a shallow copy of a portion of the original array, without modifying the original.\n5.  **Code Example(s)**:\n\n    ```javascript\n    let fruits = ['apple', 'banana', 'cherry'];\n\n    // Add\n    fruits.push('date');      // ['apple', 'banana', 'cherry', 'date']\n    fruits.unshift('apricot'); // ['apricot', 'apple', 'banana', 'cherry', 'date']\n    console.log(\"After adding:\", fruits);\n\n    // Modify\n    fruits[2] = 'blueberry'; // ['apricot', 'apple', 'blueberry', 'cherry', 'date']\n    console.log(\"After modifying:\", fruits);\n\n    // Remove\n    let lastFruit = fruits.pop();    // 'date', fruits is now ['apricot', 'apple', 'blueberry', 'cherry']\n    let firstFruit = fruits.shift(); // 'apricot', fruits is now ['apple', 'blueberry', 'cherry']\n    console.log(\"After removing:\", fruits);\n\n    // Using splice\n    fruits.splice(1, 1, 'grape', 'kiwi'); // At index 1, remove 1 element ('blueberry'), add 'grape', 'kiwi'\n    // fruits is now ['apple', 'grape', 'kiwi', 'cherry']\n    console.log(\"After splice:\", fruits);\n    ```\n\n---\n\n### **Question 8: Intermediate**\n\n1.  **Main Question**: Explain the concept of `this` in JavaScript. How does its value typically change depending on how a function is called?\n2.  **Answer**: `this` is a special keyword in JavaScript that refers to the context in which a function is executed. Its value is determined dynamically at runtime, based on how the function is called.\n    *   **Global Context**: In the global scope (outside any function), `this` refers to the global object (`window` in browsers, `global` in Node.js).\n    *   **Method Call**: When a function is called as a method of an object (e.g., `obj.method()`), `this` refers to the object that owns the method (`obj`).\n    *   **Simple Function Call**: When a function is called as a standalone function (not as a method, e.g., `func()`), `this` refers to the global object in non-strict mode, and `undefined` in strict mode.\n    *   **Constructor Call**: When a function is used as a constructor with the `new` keyword (e.g., `new MyObject()`), `this` refers to the newly created instance of the object.\n    *   **Explicit Binding (`call`, `apply`, `bind`)**: You can explicitly set the value of `this` using these methods.\n    *   **Arrow Functions**: Arrow functions do not have their own `this` binding. They lexically inherit `this` from their enclosing scope.\n3.  **Follow-up Questions**:\n    *   How does `this` behave inside an arrow function compared to a regular function?\n    *   What is strict mode, and how does it affect `this`?\n    *   Can you predict the value of `this` in a nested function call?\n4.  **Follow-up Answers**:\n    *   Inside an arrow function, `this` is determined by the surrounding lexical (enclosing) scope and cannot be changed by `call`, `apply`, or `bind`. In contrast, a regular function's `this` is dynamically bound based on how it's called.\n    *   Strict mode (`'use strict';`) is a way to opt into a restricted variant of JavaScript. In strict mode, if a function is called as a standalone function (not a method), `this` will be `undefined` instead of the global object. It also prevents accidental global variable creation and throws errors for certain unsafe actions.\n    *   In a nested regular function call, if the inner function is called as a simple function (not a method of an object), its `this` will default to the global object (or `undefined` in strict mode), *not* the `this` of the outer function. This is a common source of confusion, which arrow functions help to solve.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Global context\n    console.log(this === global); // In Node.js: true\n\n    // Method call\n    const myObject = {\n        name: 'John',\n        greet: function() {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n    myObject.greet(); // Output: Hello, my name is John (this is myObject)\n\n    // Simple function call (in Node.js, non-strict mode)\n    const greetFunc = myObject.greet;\n    // greetFunc(); // Output: Hello, my name is undefined (this is global/undefined)\n\n    // Arrow function (lexical this)\n    const anotherObject = {\n        name: 'Jane',\n        greetArrow: () => {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n    anotherObject.greetArrow(); // Output: Hello, my name is undefined (this is global/undefined, as arrow func inherits from global scope here)\n\n    // Corrected arrow function usage for 'this'\n    const yetAnotherObject = {\n        name: 'Peter',\n        sayLater: function() {\n            setTimeout(() => {\n                console.log(`Hello, my name is ${this.name}`); // 'this' here refers to 'yetAnotherObject'\n            }, 100);\n        }\n    };\n    yetAnotherObject.sayLater(); // Output: Hello, my name is Peter (after 100ms)\n    ```\n\n---\n\n### **Question 9: Intermediate**\n\n1.  **Main Question**: What are arrow functions (`=>`) in ES6, and what are their primary advantages and disadvantages compared to traditional function expressions?\n2.  **Answer**: Arrow functions provide a more concise syntax for writing function expressions.\n    *   **Advantages**:\n        *   **Concise Syntax**: Shorter to write, especially for single-expression functions.\n        *   **Lexical `this` Binding**: They do not have their own `this` context. Instead, `this` is inherited from the enclosing (lexical) scope. This solves common `this` binding issues in callbacks and nested functions.\n        *   **No `arguments` object**: They do not have their own `arguments` object, but you can use rest parameters (`...args`) instead.\n        *   **Cannot be used as constructors**: They cannot be called with `new`.\n    *   **Disadvantages**:\n        *   **No `this` binding**: This can be a disadvantage when you *need* a dynamic `this` (e.g., in object methods that need to refer to the object itself, or event handlers that need to refer to the element).\n        *   **No `arguments` object**: If you need access to the `arguments` object, you'd have to use a regular function or convert `arguments` to a rest parameter.\n        *   **Cannot be used as constructors**: You cannot use `new` with arrow functions.\n        *   **Lack of `prototype` property**: They don't have a `prototype` property, so they can't be used to create methods on a prototype chain.\n3.  **Follow-up Questions**:\n    *   When would an arrow function be a poor choice for an object method?\n    *   Can you use `yield` inside an arrow function?\n    *   How would you pass multiple arguments to an arrow function if it doesn't have an `arguments` object?\n4.  **Follow-up Answers**:\n    *   An arrow function would be a poor choice for an object method if that method needs to access the object's properties using `this`. Because arrow functions lexically bind `this`, `this` would refer to the surrounding scope (often the global object or `undefined` in strict mode), not the object itself.\n    *   No, you cannot use the `yield` keyword inside an arrow function. This means arrow functions cannot be used as generator functions.\n    *   You would use rest parameters (`...args`) to collect multiple arguments into an array. For example: `const sum = (...numbers) => numbers.reduce((acc, num) => acc + num, 0);`\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Concise syntax\n    const add = (a, b) => a + b;\n    console.log(add(2, 3)); // Output: 5\n\n    // Lexical this binding\n    function Counter() {\n        this.count = 0;\n        // Regular function would have 'this' point to setTimeout's caller (global/undefined)\n        // Arrow function preserves 'this' from Counter's scope\n        setTimeout(() => {\n            this.count++;\n            console.log(this.count); // Correctly increments Counter's count\n        }, 1000);\n    }\n    const myCounter = new Counter(); // Output: 1 (after 1 second)\n\n    // Bad example for object method\n    const user = {\n        name: 'Alice',\n        greet: () => {\n            console.log(`Hello, ${this.name}`); // 'this' refers to global object\n        }\n    };\n    user.greet(); // Output: Hello, undefined (in Node.js) or Hello, [window.name] (in browser)\n    ```\n\n---\n\n### **Question 10: Intermediate**\n\n1.  **Main Question**: What are callback functions in JavaScript? Provide a simple example of their use.\n2.  **Answer**: A callback function is a function passed as an argument to another function, which is then executed inside the outer function at a later point in time. Callbacks are a fundamental concept for asynchronous programming in JavaScript, but they are also used in synchronous contexts (e.g., array methods like `map`, `filter`).\n3.  **Follow-up Questions**:\n    *   What is \"callback hell\" or the \"pyramid of doom,\" and how can it be avoided?\n    *   Can a callback function be synchronous? Provide an example.\n    *   How do event listeners commonly use callbacks?\n4.  **Follow-up Answers**:\n    *   \"Callback hell\" is a situation in asynchronous JavaScript where multiple nested callbacks make the code difficult to read, understand, and maintain. It's often characterized by deeply indented code. It can be avoided using Promises, `async/await`, or named functions for better modularity.\n    *   Yes, a callback function can be synchronous. For example, array methods like `forEach`, `map`, or `filter` take synchronous callback functions that are executed immediately for each element.\n    *   Event listeners (e.g., for click events, data received) are a classic example of asynchronous callbacks. When an event occurs, the registered callback function is executed. The main program flow doesn't wait for the event; it continues execution, and the callback is invoked when the event happens.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Synchronous callback example (Array.forEach)\n    const numbers = [1, 2, 3];\n    numbers.forEach(function(number) {\n        console.log(number * 2); // Output: 2, 4, 6\n    });\n\n    // Asynchronous callback example (setTimeout)\n    function fetchData(callback) {\n        console.log(\"Fetching data...\");\n        setTimeout(function() {\n            const data = \"Some data from server\";\n            console.log(\"Data fetched!\");\n            ",
  "Welcome to Day 2 of your interview prep! It's great to have you here. Today, we'll continue our deep dive into JavaScript and Node.js, building upon the foundational concepts we discussed yesterday. We'll explore some more advanced JavaScript features and start touching on Node.js specifics.\n\nDon't worry, we'll maintain a friendly and supportive atmosphere. Think of this as another opportunity to showcase your understanding and learn along the way.\n\nLet's begin!\n\n---\n\n### **Question 1: Basic**\n\n1.  **Main Question**: What are Template Literals (also known as Template Strings) in ES6, and what are their primary advantages over traditional string concatenation?\n2.  **Answer**: Template Literals are a new way to define strings in JavaScript, introduced in ES6 (ECMAScript 2015). They are enclosed by backticks (`` ` ``) instead of single or double quotes.\n    *   **Interpolation**: They allow for easy embedding of expressions (variables, function calls, arithmetic) directly within the string using the `${expression}` syntax.\n    *   **Multi-line Strings**: They can span multiple lines without needing special characters like `\\n`.\n    *   **Tagged Templates**: A more advanced feature allowing a function to parse the template literal, giving fine-grained control over how the string is constructed.\n3.  **Follow-up Questions**:\n    *   Can you embed any JavaScript expression inside `${}` within a template literal?\n    *   What happens if you try to use single or double quotes for a template literal?\n    *   What is a \"tagged template\" and how might it be used?\n4.  **Follow-up Answers**:\n    *   Yes, you can embed any valid JavaScript expression, including variables, function calls, arithmetic operations, and even conditional (ternary) operators.\n    *   If you use single or double quotes, it will be treated as a regular string literal, and the special features of template literals (like interpolation or multi-line support) will not work. For example, `${}` would be treated as literal characters.\n    *   A tagged template is a function called with a template literal. The function receives the string parts as its first argument (an array of strings), and then the values of the interpolated expressions as subsequent arguments. This can be used for things like automatic escaping of HTML, internationalization, or specialized string parsing.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Interpolation\n    const name = \"Alice\";\n    const age = 30;\n    const greeting = `Hello, ${name}! You are ${age} years old.`;\n    console.log(greeting); // Output: Hello, Alice! You are 30 years old.\n\n    // Multi-line string\n    const multiLine = `This is the first line.\n    This is the second line.\n        This is indented.`;\n    console.log(multiLine);\n    ```\n\n---\n\n### **Question 2: Basic**\n\n1.  **Main Question**: Explain Destructuring Assignment in JavaScript. Provide examples for both array and object destructuring.\n2.  **Answer**: Destructuring assignment is an ES6 feature that allows you to unpack values from arrays or properties from objects into distinct variables. It provides a more concise and readable way to extract data.\n    *   **Array Destructuring**: Extracts values from an array by matching variables to elements based on their position.\n    *   **Object Destructuring**: Extracts properties from an object by matching variables to property names.\n3.  **Follow-up Questions**:\n    *   Can you assign default values during destructuring? Provide an example.\n    *   How would you skip elements when destructuring an array?\n    *   What is the benefit of using destructuring in function parameters?\n4.  **Follow-up Answers**:\n    *   Yes, you can assign default values. If the extracted value is `undefined`, the default value will be used. Example: `const { name, age = 25 } = person;`\n    *   To skip elements when destructuring an array, you can simply leave a comma placeholder. Example: `const [first, , third] = [1, 2, 3];` (skips the second element).\n    *   Using destructuring in function parameters makes the function signature clearer about what properties or elements it expects from an object or array, and it allows for direct access to those values without needing to use dot notation repeatedly inside the function body. It also enables setting default values for parameters concisely.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Array Destructuring\n    const colors = ['red', 'green', 'blue'];\n    const [firstColor, secondColor] = colors;\n    console.log(firstColor);  // Output: red\n    console.log(secondColor); // Output: green\n\n    // Object Destructuring\n    const user = {\n        id: 1,\n        username: 'coder123',\n        email: 'coder@example.com'\n    };\n    const { username, email } = user;\n    console.log(username); // Output: coder123\n    console.log(email);    // Output: coder@example.com\n    ```\n\n---\n\n### **Question 3: Basic**\n\n1.  **Main Question**: What is the Spread Operator (`...`) in JavaScript, and what are its common use cases?\n2.  **Answer**: The Spread Operator (`...`) is an ES6 feature that allows an iterable (like an array or a string) to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) or key-value pairs (for object literals) are expected. It essentially \"spreads\" the elements of an iterable.\n    *   **Copying Arrays/Objects**: Creates a shallow copy.\n    *   **Concatenating/Merging Arrays/Objects**: Combines multiple arrays or objects.\n    *   **Passing arguments to functions**: Expands an array into individual arguments.\n3.  **Follow-up Questions**:\n    *   How does the spread operator differ from array `slice()` for copying arrays?\n    *   What kind of copy (shallow vs. deep) does the spread operator perform for objects and arrays?\n    *   Can the spread operator be used for strings? If so, what's the result?\n4.  **Follow-up Answers**:\n    *   Both `spread` and `slice()` create shallow copies of arrays. The spread operator is generally more concise and versatile as it can also be used for objects and in function arguments.\n    *   The spread operator performs a **shallow copy**. This means that if the array or object contains nested objects or arrays, those nested structures are still referenced by memory, not copied. Changes to nested structures in the copy will affect the original.\n    *   Yes, the spread operator can be used for strings. It will spread the string into individual characters. For example, `[...'hello']` would result in `['h', 'e', 'l', 'l', 'o']`.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Copying and Merging Arrays\n    const arr1 = [1, 2, 3];\n    const arr2 = [...arr1, 4, 5]; // Copy arr1 and add more elements\n    console.log(arr2); // Output: [1, 2, 3, 4, 5]\n\n    // Merging Objects\n    const obj1 = { a: 1, b: 2 };\n    const obj2 = { c: 3, d: 4 };\n    const mergedObj = { ...obj1, ...obj2 };\n    console.log(mergedObj); // Output: { a: 1, b: 2, c: 3, d: 4 }\n\n    // Passing arguments to a function\n    function sum(a, b, c) {\n        return a + b + c;\n    }\n    const numbers = [1, 2, 3];\n    console.log(sum(...numbers)); // Output: 6\n    ```\n\n---\n\n### **Question 4: Basic**\n\n1.  **Main Question**: What are Rest Parameters (`...`) in JavaScript, and how do they differ from the Spread Operator?\n2.  **Answer**: Rest Parameters (`...`) are an ES6 feature that allows a function to accept an indefinite number of arguments as an array. They collect all remaining arguments into a single array.\n    The key difference from the Spread Operator is their context of use:\n    *   **Rest Parameters**: Used in **function definitions** to collect multiple arguments into an array.\n    *   **Spread Operator**: Used in **function calls**, array literals, or object literals to expand an iterable into individual elements/arguments/properties.\n3.  **Follow-up Questions**:\n    *   Can a function have multiple rest parameters? Why or why not?\n    *   Where must the rest parameter be placed in a function's parameter list?\n    *   How do rest parameters provide a more modern alternative to the `arguments` object?\n4.  **Follow-up Answers**:\n    *   No, a function can only have one rest parameter. It must be the last parameter in the list because it collects \"all remaining\" arguments. If there were multiple, it would be ambiguous which arguments each rest parameter should collect.\n    *   The rest parameter must always be the last parameter in a function's parameter list.\n    *   Rest parameters provide a modern and often preferred alternative to the deprecated `arguments` object because they give you a real array (not an array-like object), allowing you to use array methods directly on it. They also only capture the arguments that aren't explicitly defined as named parameters, making function signatures clearer.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Rest Parameters in a function definition\n    function sumAll(firstNum, ...remainingNums) {\n        let total = firstNum;\n        for (const num of remainingNums) {\n            total += num;\n        }\n        return total;\n    }\n\n    console.log(sumAll(1, 2, 3, 4)); // Output: 10 (1 is firstNum, [2,3,4] is remainingNums)\n    console.log(sumAll(5));         // Output: 5 (5 is firstNum, [] is remainingNums)\n\n    // Example showing difference between Rest and Spread\n    const numbers = [10, 20, 30];\n\n    // Spread: expands array into individual arguments\n    console.log(Math.max(...numbers)); // Output: 30\n\n    // Rest: collects individual arguments into an array\n    function logArgs(...args) {\n        console.log(args);\n    }\n    logArgs(1, 'hello', true); // Output: [1, 'hello', true]\n    ```\n\n---\n\n### **Question 5: Basic**\n\n1.  **Main Question**: How do you handle errors in JavaScript using `try...catch` blocks? Provide a simple example.\n2.  **Answer**: The `try...catch` statement is used for error handling in JavaScript. It allows you to test a block of code for errors and handle them gracefully without crashing the program.\n    *   The `try` block contains the code that might throw an error.\n    *   If an error occurs within the `try` block, execution jumps to the `catch` block.\n    *   The `catch` block receives the error object as an argument, allowing you to inspect and respond to the error.\n    *   An optional `finally` block can be added, which will execute regardless of whether an error occurred or not (e.g., for cleanup).\n3.  **Follow-up Questions**:\n    *   What type of errors can `try...catch` handle? Are there any it cannot?\n    *   When would you use a `finally` block?\n    *   How would you intentionally throw a custom error in JavaScript?\n4.  **Follow-up Answers**:\n    *   `try...catch` can handle runtime errors (exceptions) that occur synchronously within the `try` block. It cannot directly catch syntax errors (which prevent the script from running at all) or asynchronous errors (like those inside a `setTimeout` or a Promise's rejected state, unless specifically handled with `.catch()` for Promises or nested `try...catch` for async functions).\n    *   A `finally` block is used when you have code that *must* be executed, regardless of whether an error occurred or not. Common use cases include closing file handles, releasing network connections, or cleaning up resources.\n    *   You can intentionally throw a custom error using the `throw` statement, followed by an error object (e.g., `throw new Error('Something went wrong!');` or `throw 'My custom string error';`).\n5.  **Code Example(s)**:\n\n    ```javascript\n    function divide(a, b) {\n        try {\n            if (b === 0) {\n                throw new Error(\"Division by zero is not allowed.\");\n            }\n            return a / b;\n        } catch (error) {\n            console.error(\"An error occurred:\", error.message);\n            return null; // Indicate failure\n        } finally {\n            console.log(\"Division attempt finished.\");\n        }\n    }\n\n    console.log(divide(10, 2)); // Output: 5, then \"Division attempt finished.\"\n    console.log(divide(10, 0)); // Output: \"An error occurred: Division by zero is not allowed.\", then \"Division attempt finished.\", then null\n    ```\n\n---\n\n### **Question 6: Basic**\n\n1.  **Main Question**: What are the fundamental differences between JavaScript running in a web browser and JavaScript running in Node.js?\n2.  **Answer**: While both environments execute JavaScript, they differ significantly in their runtime environments and available APIs:\n    *   **Runtime Environment**:\n        *   **Browser JS**: Runs in the browser's JavaScript engine (e.g., V8 in Chrome, SpiderMonkey in Firefox). It interacts with the DOM, browser events, and browser-specific APIs (e.g., `window`, `document`, `localStorage`).\n        *   **Node.js**: Runs in the Node.js runtime, which also uses the V8 engine, but outside the browser. It interacts with the operating system, file system, network, and Node.js-specific APIs (e.g., `fs`, `http`, `path`, `process`).\n    *   **Global Objects**:\n        *   **Browser JS**: Global object is `window`.\n        *   **Node.js**: Global object is `global`.\n    *   **Modules**:\n        *   **Browser JS**: Traditionally used `<script>` tags, now supports ES Modules (`import`/`export`).\n        *   **Node.js**: Primarily uses CommonJS modules (`require`/`module.exports`), with increasing support for ES Modules.\n    *   **Purpose**:\n        *   **Browser JS**: Primarily for client-side interactivity, UI manipulation, and consuming web APIs.\n        *   **Node.js**: Primarily for server-side development, command-line tools, backend APIs, and handling I/O operations.\n3.  **Follow-up Questions**:\n    *   Can you use `document.getElementById()` in Node.js? Why or why not?\n    *   What is the role of the V8 engine in both environments?\n    *   How does Node.js handle I/O operations differently from a typical browser-based JavaScript application?\n4.  **Follow-up Answers**:\n    *   No, you cannot use `document.getElementById()` in Node.js because `document` is part of the Browser Object Model (BOM) and Document Object Model (DOM), which are specific to web browsers and do not exist in the Node.js runtime.\n    *   The V8 engine is Google's open-source JavaScript engine that compiles JavaScript into machine code. Its role in both environments is to parse and execute JavaScript code efficiently. Node.js leverages V8's speed and non-blocking I/O model for server-side operations, while browsers use it for client-side script execution.\n    *   Node.js handles I/O operations (like file system access or network requests) using a non-blocking, event-driven architecture, primarily through an event loop and libuv (a C++ library). This allows Node.js to perform I/O operations concurrently without blocking the main thread. Browser-based JS also uses an event loop for asynchronous operations, but its I/O is typically limited to network requests (Fetch API, XMLHttpRequest) and user interaction, not direct file system access.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Browser-specific code (will error in Node.js)\n    // console.log(window);\n    // document.body.style.backgroundColor = 'blue';\n\n    // Node.js-specific code (will error in browser without a bundler)\n    // const fs = require('fs');\n    // fs.readFile('./myfile.txt', 'utf8', (err, data) => {\n    //     if (err) throw err;\n    //     console.log(data);\n    // });\n    ```\n\n---\n\n### **Question 7: Basic**\n\n1.  **Main Question**: What is NPM (Node Package Manager), and what is the purpose of the `package.json` file in a Node.js project?\n2.  **Answer**:\n    *   **NPM (Node Package Manager)**: It's the default package manager for Node.js. It serves two main purposes:\n        1.  **Software Registry**: A vast online repository of open-source Node.js packages (libraries, frameworks, tools).\n        2.  **Command-Line Utility**: A tool that helps developers install, manage, and publish Node.js packages.\n    *   **`package.json`**: This file is a manifest for a Node.js project. It's a JSON file that lives in the root directory of your project and contains metadata about the project and its dependencies.\n        *   It defines project properties like `name`, `version`, `description`, `author`, `license`.\n        *   It lists project dependencies (`dependencies` for production, `devDependencies` for development).\n        *   It defines scripts that can be run using `npm run <script-name>`.\n        *   It specifies the main entry point of the application (`main`).\n3.  **Follow-up Questions**:\n    *   What is the difference between `dependencies` and `devDependencies` in `package.json`?\n    *   How would you install a package and save it as a development dependency?\n    *   What happens when you run `npm install` in a project that already has a `package.json` file?\n4.  **Follow-up Answers**:\n    *   `dependencies` are packages required for the application to run in a production environment (e.g., Express.js, React). `devDependencies` are packages only needed during development or testing (e.g., testing frameworks like Jest, build tools like Webpack, linters like ESLint).\n    *   You would use the command `npm install <package-name> --save-dev` or `npm install <package-name> -D`.\n    *   When you run `npm install` without any arguments in a directory containing a `package.json` file, NPM reads the file and installs all the `dependencies` and `devDependencies` listed in it into the `node_modules` folder, ensuring all project requirements are met.\n5.  **Code Example(s)**:\n\n    ```json\n    // Example package.json snippet\n    {\n      \"name\": \"my-node-app\",\n      \"version\": \"1.0.0\",\n      \"description\": \"A simple Node.js application.\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\"\n      },\n      \"dependencies\": {\n        \"express\": \"^4.18.2\",\n        \"lodash\": \"^4.17.21\"\n      },\n      \"devDependencies\": {\n        \"jest\": \"^29.7.0\",\n        \"nodemon\": \"^3.0.1\"\n      },\n      \"author\": \"Your Name\",\n      \"license\": \"MIT\"\n    }\n    ```\n\n---\n\n### **Question 8: Intermediate**\n\n1.  **Main Question**: Explain the concept of \"closures\" in JavaScript. How do they work, and what are some common use cases?\n2.  **Answer**: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In simpler terms, a closure gives you access to an outer function's scope from an inner function.\n    *   **How it works**: When an inner function is defined within an outer function, the inner function \"remembers\" the environment in which it was created. Even if the outer function has finished executing and its scope would normally be destroyed, the closure keeps that scope alive for the inner function to access.\n    *   **Use Cases**:\n        *   **Data Privacy/Encapsulation**: Creating private variables or methods.\n        *   **Currying/Partial Application**: Creating specialized functions.\n        *   **Maintaining State**: In event handlers or asynchronous operations.\n        *   **Module Pattern**: Creating self-contained modules.\n3.  **Follow-up Questions**:\n    *   Can a closure access variables from its outer scope even after the outer function has returned?\n    *   What is a potential pitfall or common mistake when using closures in loops?\n    *   How are closures related to the concept of lexical scope?\n4.  **Follow-up Answers**:\n    *   Yes, this is the core characteristic of a closure. The inner function retains a reference to the outer function's scope, allowing it to access and manipulate variables from that scope even after the outer function has completed execution.\n    *   A common pitfall is when closures are created inside loops using `var`. Because `var` is function-scoped (or global) and hoisted, all closures created in the loop will share the *same* reference to the loop variable's final value, leading to unexpected results. Using `let` or `const` (which are block-scoped) or creating a new scope for each iteration can solve this.\n    *   Closures are fundamentally built upon lexical scope. Lexical scope means that the scope of a variable is determined by its position in the source code (where it's written), not by where it's called. A closure \"closes over\" its lexical environment, meaning it remembers the variables and arguments that were in scope when it was defined.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Data Privacy / Counter\n    function createCounter() {\n        let count = 0; // 'count' is a private variable due to closure\n        return {\n            increment: function() {\n                count++;\n                return count;\n            },\n            decrement: function() {\n                count--;\n                return count;\n            },\n            getCount: function() {\n                return count;\n            }\n        };\n    }\n\n    const counter = createCounter();\n    console.log(counter.increment()); // Output: 1\n    console.log(counter.increment()); // Output: 2\n    console.log(counter.getCount());  // Output: 2\n\n    // Example 2: Closure in a loop (correct way with let)\n    function createFunctions() {\n        const result = [];\n        for (let i = 0; i < 3; i++) { // Using let ensures each iteration has its own 'i'\n            result.push(function() {\n                console.log(i);\n            });\n        }\n        return result;\n    }\n    const funcs = createFunctions();\n    funcs[0](); // Output: 0\n    funcs[1](); // Output: 1\n    funcs[2](); // Output: 2\n    ```\n\n---\n\n### **Question 9: Intermediate**\n\n1.  **Main Question**: Explain the concept of the \"prototype chain\" in JavaScript. How does JavaScript achieve inheritance using prototypes?\n2.  **Answer**: In JavaScript, objects can inherit properties and methods from other objects through a mechanism called the \"prototype chain.\" Every JavaScript object has an internal `[[Prototype]]` property (accessible via `__proto__` or `Object.getPrototypeOf()`) that points to another object, which is its prototype.\n    *   **How it works**: When you try to access a property or method on an object, JavaScript first checks if the property exists directly on that object. If not, it looks for the property on the object's prototype. If still not found, it continues up the prototype chain until it either finds the property or reaches `null` (the end of the chain).\n    *   **Inheritance**: This chain allows objects to inherit properties and methods from their ancestors, mimicking classical inheritance without explicit classes (though ES6 `class` syntax is syntactic sugar over prototypes).\n3.  **Follow-up Questions**:\n    *   What is the `Object.prototype` and where does it sit in the prototype chain?\n    *   How does `instanceof` operator relate to the prototype chain?\n    *   Can you modify an object's prototype after it's been created? What are the implications?\n4.  **Follow-up Answers**:\n    *   `Object.prototype` is the base prototype for all objects in JavaScript. It sits at the very end of most prototype chains (just before `null`). It contains common methods like `toString()`, `hasOwnProperty()`, `isPrototypeOf()`, etc.\n    *   The `instanceof` operator checks if an object's prototype chain contains the `prototype` property of a constructor. For example, `myObject instanceof MyConstructor` returns `true` if `MyConstructor.prototype` exists anywhere in `myObject`'s prototype chain.\n    *   Yes, you can modify an object's prototype using `Object.setPrototypeOf()` or by directly modifying the `__proto__` property (though `__proto__` is generally discouraged for performance reasons and `Object.setPrototypeOf()` is preferred). Modifying a prototype affects all objects that inherit from it, which can have significant and sometimes unintended side effects on existing instances and future instances.\n5.  **Code Example(s)**:\n\n    ```javascript\n    // Example 1: Basic prototype chain\n    const animal = {\n        eats: true,\n        walk() {\n            console.log(\"Animal walks.\");\n        }\n    };\n\n    const rabbit = {\n        jumps: true,\n        __proto__: animal // rabbit inherits from animal\n    };\n\n    const longEar = {\n        earLength: 10,\n        __proto__: rabbit // longEar inherits from rabbit, which inherits from animal\n    };\n\n    console.log(longEar.eats); // Output: true (inherited from animal)\n    longEar.walk();            // Output: Animal walks. (inherited from animal)\n    console.log(longEar.jumps); // Output: true (inherited from rabbit)\n\n    // Example 2: Using Object.create\n    const personPrototype = {\n        greet() {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n\n    const john = Object.create(personPrototype);\n    john.name = \"John\";\n    john.greet(); // Output: Hello, my name is John\n    ```\n\n---\n\n### **Question "
]